<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ°Ô∏è Helm Enhanced Dashboard</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden; /* Prevent body from scrolling */
        }
        
        html {
            overflow: hidden; /* Also prevent html scrollbar */
        }
        
        .dashboard-container {
            max-width: 1200px;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            flex-shrink: 0;
        }
        
        .header h1 {
            color: #667eea;
            font-size: 2rem;
            margin-bottom: 5px;
        }
        
        .status-bar {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 10;
            flex-shrink: 0;
        }
        
        .status-item {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            padding: 6px 12px;
            text-align: center;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        .chat-section {
            background: rgba(26, 26, 46, 0.8);
            border: 1px solid #3a3a5e;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 120px); /* Full height minus header and status */
            position: relative;
            overflow: hidden;
        }
        
        /* Chat Message Bubbles */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: rgba(26, 26, 46, 0.5);
            border-radius: 12px;
            border: 1px solid #3a3a5e;
            margin-bottom: 15px;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
            min-height: 0; /* Allow flexbox to work properly */
            /* Custom scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: #667eea #2a2a3e;
            /* Ensure scrolling works properly */
            display: flex;
            flex-direction: column;
        }
        
        /* Custom scrollbar for Webkit browsers */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .chat-container::-webkit-scrollbar-track {
            background: #2a2a3e;
            border-radius: 4px;
        }
        
        .chat-container::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }
        
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }
        
        .message-bubble {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            animation: fadeIn 0.3s ease-in;
        }
        
        .message-bubble.user {
            justify-content: flex-end;
        }
        
        .message-bubble.assistant {
            justify-content: flex-start;
        }
        
        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            position: relative;
        }
        
        .message-bubble.user .message-content {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-bottom-right-radius: 4px;
        }
        
        .message-bubble.assistant .message-content {
            background: rgba(58, 58, 94, 0.8);
            color: #e0e0e0;
            border-bottom-left-radius: 4px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }
        
        .message-time {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 4px;
            opacity: 0.7;
        }
        
        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            margin: 0 8px;
        }
        
        .message-bubble.user .message-avatar {
            background: linear-gradient(135deg, #667eea, #764ba2);
            order: 1;
        }
        
        .message-bubble.assistant .message-avatar {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.5);
        }
        
        .chat-input-container {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 12px;
            background: rgba(26, 26, 46, 0.8);
            border: 1px solid #3a3a5e;
            border-radius: 12px;
            flex-shrink: 0; /* Prevent input container from growing */
            position: sticky;
            bottom: 0;
            z-index: 5;
            backdrop-filter: blur(10px);
        }
        
        .upload-button {
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .upload-button:hover {
            background: linear-gradient(135deg, #764ba2, #667eea);
            transform: translateY(-1px);
        }
        
        .upload-button:active {
            transform: translateY(0);
        }
        
        .chat-input {
            flex: 1;
            padding: 12px 16px;
            background: rgba(58, 58, 94, 0.6);
            border: 1px solid #3a3a5e;
            border-radius: 25px;
            color: #e0e0e0;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
        }
        
        /* File Upload Styles */
        .file-upload-section {
            background: rgba(26, 26, 46, 0.8);
            border: 1px solid #3a3a5e;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .file-upload-area {
            border: 2px dashed #3a3a5e;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: rgba(58, 58, 94, 0.2);
        }
        
        .file-upload-area:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        
        .file-upload-area.dragging {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.2);
            transform: scale(1.02);
        }
        
        .file-upload-icon {
            font-size: 24px;
            margin-bottom: 8px;
            color: #667eea;
        }
        
        .file-upload-text {
            color: #e0e0e0;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .file-upload-hint {
            color: #9ca3af;
            font-size: 12px;
        }
        
        .file-input {
            display: none;
        }
        
        .uploaded-files {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .uploaded-file {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(58, 58, 94, 0.4);
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            animation: fadeIn 0.3s ease-in;
        }
        
        .uploaded-file-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .uploaded-file-icon {
            font-size: 16px;
        }
        
        .uploaded-file-details {
            flex: 1;
        }
        
        .uploaded-file-name {
            color: #e0e0e0;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }
        
        .uploaded-file-size {
            color: #9ca3af;
            font-size: 10px;
        }
        
        .uploaded-file-preview {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            object-fit: cover;
            border: 1px solid #3a3a5e;
        }
        
        .remove-file-btn {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #ef4444;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .remove-file-btn:hover {
            background: rgba(239, 68, 68, 0.3);
        }
        
        /* File Upload Modal */
        .upload-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .upload-modal-content {
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid #3a3a5e;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .upload-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .upload-modal-title {
            color: #e0e0e0;
            font-size: 18px;
            font-weight: 600;
        }
        
        .close-modal-btn {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .close-modal-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        
        .chat-input:focus {
            border-color: #667eea;
            background: rgba(58, 58, 94, 0.8);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .chat-input::placeholder {
            color: #9ca3af;
        }
        
        .model-select {
            padding: 6px 10px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 12px;
            min-width: 100px;
            flex-shrink: 0;
        }
        
        .chat-send-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 13px;
            flex-shrink: 0;
        }
        
        .chat-send-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .chat-send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 8px 12px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
            animation: pulse 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        .logo-display {
            margin-top: 20px;
            text-align: center;
        }
        
        .logo-display canvas {
            border: 2px solid #3a3a5e;
            border-radius: 8px;
            background: white;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const EnhancedHelmChat = () => {
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [selectedModel, setSelectedModel] = useState('phi');
            const [isLoading, setIsLoading] = useState(false);
            const [helmStatus, setHelmStatus] = useState({ running: false });
            const [pendingAssets, setPendingAssets] = useState([]);
            const [uploadedFiles, setUploadedFiles] = useState([]);
            const [isDragging, setIsDragging] = useState(false);
            const [showUploadModal, setShowUploadModal] = useState(false);
            const [confirmationMode, setConfirmationMode] = useState(false);
            const [pendingRequest, setPendingRequest] = useState(null);
            const [confirmationQuestions, setConfirmationQuestions] = useState([]);
            const [confirmationAnswers, setConfirmationAnswers] = useState({});
            const [sessionId] = useState(generateSecureSessionId());
            const [requestCount, setRequestCount] = useState(0);
            const [lastRequestTime, setLastRequestTime] = useState(Date.now());
            const [isRateLimited, setIsRateLimited] = useState(false);
            
            const availableModels = ['tinyllama', 'phi', 'qwen:0.5b', 'deepseek-coder:1.3b'];
            
            // Smart model selection based on prompt content
            const selectBestModel = (prompt) => {
                const lowerPrompt = prompt.toLowerCase();
                
                if (lowerPrompt.includes('code') || lowerPrompt.includes('analyze') || lowerPrompt.includes('debug')) {
                    return 'deepseek-coder:1.3b';
                } else if (lowerPrompt.includes('create') || lowerPrompt.includes('logo') || lowerPrompt.includes('design')) {
                    return 'phi';
                } else if (lowerPrompt.includes('quick') || lowerPrompt.includes('help')) {
                    return 'tinyllama';
                } else {
                    return 'phi'; // default balanced model
                }
            };
            
            // Auto-select model when input changes
            useEffect(() => {
                if (input.length > 10) {
                    const bestModel = selectBestModel(input);
                    setSelectedModel(bestModel);
                }
            }, [input]);
            
            useEffect(() => {
                checkHelmStatus();
            }, []);
            
            const checkHelmStatus = async () => {
                try {
                    const response = await fetch('http://localhost:3001/helm/status');
                    const data = await response.json();
                    setHelmStatus(data);
                } catch (error) {
                    console.log('Helm not connected');
                }
            };
            
            const sendMessage = async () => {
                if (!input.trim()) return;
                
                // Security: Check rate limiting
                if (!checkRateLimit()) {
                    const rateLimitMessage = {
                        content: 'üö´ Rate limit exceeded. Please wait a moment before sending another message.',
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isError: true
                    };
                    setMessages(prev => [...prev, rateLimitMessage]);
                    return;
                }
                
                // Security: Sanitize input
                const sanitizedInput = sanitizeInput(input);
                
                // Security: Monitor for suspicious activity
                if (monitorSuspiciousActivity('sendMessage', { input: sanitizedInput })) {
                    return;
                }
                
                const userMessage = {
                    content: sanitizedInput,
                    isUser: true,
                    timestamp: new Date().toISOString()
                };
                
                setMessages(prev => [...prev, userMessage]);
                setIsLoading(true);
                
                // Advanced AI-powered detection system
                const lowerInput = input.toLowerCase();
                const words = lowerInput.split(/\s+/);
                
                // Sophisticated intent detection
                const detectIntent = (text) => {
                    const creationVerbs = ['create', 'make', 'design', 'generate', 'draw', 'craft', 'build', 'produce', 'develop', 'render', 'illustrate', 'craft', 'form', 'construct', 'produce', 'make me', 'give me', 'i need', 'i want', 'can you', 'could you'];
                    const visualNouns = ['logo', 'icon', 'image', 'picture', 'graphic', 'art', 'design', 'visual', 'emblem', 'symbol', 'badge', 'insignia', 'mark', 'brand', 'avatar', 'portrait', 'illustration', 'emote', 'emoji', 'face', 'smiley', 'sticker', 'name badge', 'nametag', 'id badge', 'border', 'frame', 'avatar border', 'profile frame', 'banner', 'header', 'background', 'pattern', 'texture', 'shield', 'crest', 'seal', 'stamp', 'button', 'ui element', 'interface', 'widget', 'cartoon', 'chibi', 'anime', 'manga', 'sketch', 'drawing', 'painting', 'watercolor', 'pixel art', 'vector art', 'stylized', 'artistic', 'caricature'];
                    const audioNouns = ['sound', 'audio', 'music', 'track', 'beat', 'melody', 'tune', 'effect', 'sfx', 'noise', 'clip', 'recording'];
                    const pokerTerms = ['poker', 'card', 'chip', 'table', 'felt', 'suit', 'spade', 'heart', 'diamond', 'club', 'deck', 'dealer', 'player', 'casino'];
                    
                    // Check for creation intent
                    const hasCreationVerb = creationVerbs.some(verb => text.includes(verb));
                    
                    // Check for visual asset intent
                    const hasVisualNoun = visualNouns.some(noun => text.includes(noun));
                    
                    // Check for audio asset intent
                    const hasAudioNoun = audioNouns.some(noun => text.includes(noun));
                    
                    // Check for poker-specific context
                    const hasPokerContext = pokerTerms.some(term => text.includes(term));
                    
                    // Advanced pattern matching
                    const patterns = {
                        // Logo patterns
                        logo: [
                            /\b(create|make|design|generate|draw).+logo\b/,
                            /\blogo.+for\b/,
                            /\bneed.+logo\b/,
                            /\blogo.+design\b/,
                            /\bbrand.+logo\b/,
                            /\bcompany.+logo\b/,
                            /\blogo.+represent\b/,
                            /\blogo.+symboliz\b/,
                            /\bemblem.+for\b/,
                            /\bsymbol.+for\b/
                        ],
                        // Emote patterns
                        emote: [
                            /\b(create|make|design).+emote\b/,
                            /\b(create|make|design).+emoji\b/,
                            /\b(create|make|design).+face\b/,
                            /\b(create|make|design).+smiley\b/,
                            /\bemote.+express\b/,
                            /\bemoji.+show\b/,
                            /\bface.+show\b/
                        ],
                        // Badge patterns
                        badge: [
                            /\b(create|make|design|generate).+badge\b/,
                            /\b(create|make|design|generate).+name.+badge\b/,
                            /\b(create|make|design|generate).+nametag\b/,
                            /\b(create|make|design|generate).+id.+badge\b/,
                            /\b(create|make|design|generate).+identification\b/,
                            /\bbadge.+for\b/,
                            /\bnametag.+with\b/,
                            /\bid.+badge.+show\b/
                        ],
                        // Border patterns
                        border: [
                            /\b(create|make|design|generate).+border\b/,
                            /\b(create|make|design|generate).+frame\b/,
                            /\b(create|make|design|generate).+avatar.+border\b/,
                            /\b(create|make|design|generate).+profile.+frame\b/,
                            /\b(create|make|design|generate).+picture.+frame\b/,
                            /\b(create|make|design|generate).+photo.+frame\b/,
                            /\bborder.+around\b/,
                            /\bframe.+for\b/
                        ],
                        // Banner patterns
                        banner: [
                            /\b(create|make|design|generate).+banner\b/,
                            /\b(create|make|design|generate).+header\b/,
                            /\b(create|make|design|generate).+background\b/,
                            /\b(create|make|design|generate).+pattern\b/,
                            /\b(create|make|design|generate).+texture\b/,
                            /\bbanner.+for\b/,
                            /\bheader.+with\b/,
                            /\bbackground.+design\b/
                        ],
                        // Shield/Crest patterns
                        shield: [
                            /\b(create|make|design|generate).+shield\b/,
                            /\b(create|make|design|generate).+crest\b/,
                            /\b(create|make|design|generate).+seal\b/,
                            /\b(create|make|design|generate).+stamp\b/,
                            /\bshield.+for\b/,
                            /\bcrest.+with\b/,
                            /\bseal.+design\b/,
                            /\bstamp.+official\b/
                        ],
                        // Art style patterns
                        artStyle: [
                            /\b(create|make|design|generate).+cartoon\b/,
                            /\b(create|make|design|generate).+chibi\b/,
                            /\b(create|make|design|generate).+anime\b/,
                            /\b(create|make|design|generate).+manga\b/,
                            /\b(create|make|design|generate).+sketch\b/,
                            /\b(create|make|design|generate).+drawing\b/,
                            /\b(create|make|design|generate).+painting\b/,
                            /\b(create|make|design|generate).+watercolor\b/,
                            /\b(create|make|design|generate).+pixel.+art\b/,
                            /\b(create|make|design|generate).+vector.+art\b/,
                            /\b(create|make|design|generate).+stylized\b/,
                            /\b(create|make|design|generate).+artistic\b/,
                            /\b(create|make|design|generate).+caricature\b/,
                            /\bturn.+into.+cartoon\b/,
                            /\bmake.+cartoon.+of\b/,
                            /\bcreate.+chibi.+version\b/,
                            /\banime.+style\b/,
                            /\bmanga.+style\b/,
                            /\bsketch.+style\b/,
                            /\bpainting.+style\b/,
                            /\bartistic.+style\b/,
                            /\bstylized.+version\b/
                        ],
                        // Audio patterns
                        audio: [
                            /\b(create|make|design|generate).+sound\b/,
                            /\b(create|make|design|generate).+audio\b/,
                            /\b(create|make|design|generate).+music\b/,
                            /\b(create|make|design|generate).+effect\b/,
                            /\bsound.+effect\b/,
                            /\baudio.+clip\b/,
                            /\bbackground.+music\b/,
                            /\bbgm\b/,
                            /\bsfx\b/
                        ],
                        // Poker asset patterns
                        poker: [
                            /\b(create|make|design).+card.+back\b/,
                            /\b(create|make|design).+playing.+card\b/,
                            /\b(create|make|design).+poker.+chip\b/,
                            /\b(create|make|design).+poker.+table\b/,
                            /\b(create|make|design).+card.+suit\b/,
                            /\b(create|make|design).+poker.+avatar\b/,
                            /\bcard.+back\b/,
                            /\bpoker.+chip\b/,
                            /\btable.+felt\b/
                        ]
                    };
                    
                    // Test patterns
                    const matchedPatterns = {};
                    Object.keys(patterns).forEach(type => {
                        matchedPatterns[type] = patterns[type].some(pattern => pattern.test(text));
                    });
                    
                    // Determine intent with confidence scoring
                    const intent = {
                        logo: {
                            score: 0,
                            detected: false
                        },
                        emote: {
                            score: 0,
                            detected: false
                        },
                        badge: {
                            score: 0,
                            detected: false
                        },
                        border: {
                            score: 0,
                            detected: false
                        },
                        banner: {
                            score: 0,
                            detected: false
                        },
                        shield: {
                            score: 0,
                            detected: false
                        },
                        artStyle: {
                            score: 0,
                            detected: false
                        },
                        audio: {
                            score: 0,
                            detected: false
                        },
                        poker: {
                            score: 0,
                            detected: false
                        }
                    };
                    
                    // Score calculation
                    if (hasCreationVerb) {
                        if (hasVisualNoun) {
                            if (text.includes('logo') || matchedPatterns.logo) {
                                intent.logo.score += 10;
                                intent.logo.detected = true;
                            }
                            if (text.includes('emote') || text.includes('emoji') || text.includes('face') || matchedPatterns.emote) {
                                intent.emote.score += 10;
                                intent.emote.detected = true;
                            }
                            if (text.includes('badge') || text.includes('nametag') || text.includes('id badge') || matchedPatterns.badge) {
                                intent.badge.score += 10;
                                intent.badge.detected = true;
                            }
                            if (text.includes('border') || text.includes('frame') || text.includes('avatar border') || matchedPatterns.border) {
                                intent.border.score += 10;
                                intent.border.detected = true;
                            }
                            if (text.includes('banner') || text.includes('header') || text.includes('background') || text.includes('pattern') || matchedPatterns.banner) {
                                intent.banner.score += 10;
                                intent.banner.detected = true;
                            }
                            if (text.includes('shield') || text.includes('crest') || text.includes('seal') || text.includes('stamp') || matchedPatterns.shield) {
                                intent.shield.score += 10;
                                intent.shield.detected = true;
                            }
                            if (text.includes('cartoon') || text.includes('chibi') || text.includes('anime') || text.includes('manga') || 
                                text.includes('sketch') || text.includes('drawing') || text.includes('painting') || text.includes('watercolor') ||
                                text.includes('pixel art') || text.includes('vector art') || text.includes('stylized') || text.includes('artistic') ||
                                text.includes('caricature') || matchedPatterns.artStyle) {
                                intent.artStyle.score += 10;
                                intent.artStyle.detected = true;
                            }
                        }
                        if (hasAudioNoun || matchedPatterns.audio) {
                            intent.audio.score += 10;
                            intent.audio.detected = true;
                        }
                        if (hasPokerContext || matchedPatterns.poker) {
                            intent.poker.score += 8;
                            intent.poker.detected = true;
                        }
                    }
                    
                    // Contextual scoring
                    if (text.includes('helm') && (hasVisualNoun || hasCreationVerb)) {
                        intent.logo.score += 5;
                    }
                    
                    if (text.includes('represent') && hasVisualNoun) {
                        intent.logo.score += 3;
                    }
                    
                    if (text.includes('ai') && hasVisualNoun) {
                        intent.logo.score += 3;
                    }
                    
                    // Determine highest scoring intent
                    let highestIntent = null;
                    let highestScore = 0;
                    
                    Object.keys(intent).forEach(type => {
                        if (intent[type].score > highestScore) {
                            highestScore = intent[type].score;
                            highestIntent = type;
                        }
                    });
                    
                    return {
                        intent: highestIntent,
                        confidence: highestScore,
                        details: intent,
                        isAssetRequest: highestScore > 5
                    };
                };
                
                const detection = detectIntent(lowerInput);
                
                // If it's an asset creation request, check if confirmation is needed
                if (detection.isAssetRequest) {
                    console.log('üéØ AI Detection:', {
                        intent: detection.intent,
                        confidence: detection.confidence,
                        input: input
                    });
                    
                    // Check if we should ask confirmation questions
                    const shouldConfirm = startConfirmationProcess(input, detection);
                    
                    if (!shouldConfirm) {
                        // No confirmation needed, proceed directly
                        if (detection.intent === 'logo' || detection.intent === 'emote' || detection.intent === 'poker' || 
                            detection.intent === 'badge' || detection.intent === 'border' || detection.intent === 'banner' || detection.intent === 'shield' ||
                            detection.intent === 'artStyle') {
                            setTimeout(() => createLogo(input), 500);
                        } else if (detection.intent === 'audio') {
                            setTimeout(() => createAudio(input), 500);
                        }
                        
                        setIsLoading(false);
                        setInput('');
                        return;
                    } else {
                        // Confirmation process started, wait for answers
                        setIsLoading(false);
                        setInput('');
                        return;
                    }
                }
                
                // For non-asset requests, try to call the backend
                try {
                    const response = await fetch('http://localhost:3000/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            message: input,
                            model: selectedModel
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    const aiMessage = {
                        content: result.result?.response || result.result || 'Response received',
                        isUser: false,
                        timestamp: new Date().toISOString()
                    };
                    
                    setMessages(prev => [...prev, aiMessage]);
                    
                } catch (error) {
                    // Check if it's an asset creation request first, before showing error
                    const lowerInput = input.toLowerCase();
                    if (lowerInput.includes('create logo') || lowerInput.includes('make a logo') || 
                        lowerInput.includes('design a logo') || lowerInput.includes('generate logo') ||
                        lowerInput.includes('create icon') || lowerInput.includes('make an icon') ||
                        lowerInput.includes('create image') || lowerInput.includes('make an image') ||
                        lowerInput.includes('create emote') || lowerInput.includes('make an emote') || 
                        lowerInput.includes('create emoji') || lowerInput.includes('make an emoji') ||
                        lowerInput.includes('emote') || lowerInput.includes('emoji') ||
                        lowerInput.includes('card back') || lowerInput.includes('playing card') ||
                        lowerInput.includes('poker chip') || lowerInput.includes('chip') && lowerInput.includes('poker') ||
                        lowerInput.includes('avatar') && lowerInput.includes('poker') ||
                        lowerInput.includes('table') && (lowerInput.includes('poker') || lowerInput.includes('felt')) ||
                        lowerInput.includes('suit') && (lowerInput.includes('card') || lowerInput.includes('spade') || lowerInput.includes('heart') || lowerInput.includes('diamond') || lowerInput.includes('club'))) {
                        setTimeout(() => createLogo(input), 500);
                    } else if (lowerInput.includes('create sound') || lowerInput.includes('make a sound') || lowerInput.includes('generate sound') ||
                        lowerInput.includes('create audio') || lowerInput.includes('make audio') || lowerInput.includes('generate audio') ||
                        lowerInput.includes('create music') || lowerInput.includes('make music') || lowerInput.includes('generate music') ||
                        lowerInput.includes('create shuffle sound') || lowerInput.includes('make shuffle sound') ||
                        lowerInput.includes('create chip sound') || lowerInput.includes('make chip sound') ||
                        lowerInput.includes('create win sound') || lowerInput.includes('make win sound') ||
                        lowerInput.includes('create lose sound') || lowerInput.includes('make lose sound') ||
                        lowerInput.includes('create deal sound') || lowerInput.includes('make deal sound') ||
                        lowerInput.includes('create bet sound') || lowerInput.includes('make bet sound') ||
                        lowerInput.includes('create background music') || lowerInput.includes('make background music') ||
                        lowerInput.includes('create alert sound') || lowerInput.includes('make alert sound')) {
                        setTimeout(() => createAudio(input), 500);
                    } else {
                        const errorMessage = {
                            content: 'Sorry, I encountered an error. Please make sure Helm server is running.',
                            isUser: false,
                            timestamp: new Date().toISOString()
                        };
                        setMessages(prev => [...prev, errorMessage]);
                    }
                }
                
                setIsLoading(false);
            };
            
            const createLogo = (description) => {
                const canvas = document.getElementById('logo-canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const width = 200;
                const height = 200;

                canvas.width = width;
                canvas.height = height;

                const lowerDesc = description.toLowerCase();

                // Check if it's a poker-related request
                const isPokerRelated = lowerDesc.includes('poker') || 
                                     lowerDesc.includes('card') || 
                                     lowerDesc.includes('chip') ||
                                     lowerDesc.includes('table') ||
                                     lowerDesc.includes('suit') ||
                                     lowerDesc.includes('spade') || 
                                     lowerDesc.includes('heart') || 
                                     lowerDesc.includes('diamond') || 
                                     lowerDesc.includes('club') ||
                                     lowerDesc.includes('casino') ||
                                     lowerDesc.includes('deck');

                if (lowerDesc.includes('emote') || lowerDesc.includes('emoji') || lowerDesc.includes('face') || lowerDesc.includes('smiley')) {
                    createEmote(ctx, width, height, lowerDesc);
                } else if (lowerDesc.includes('badge') || lowerDesc.includes('nametag') || lowerDesc.includes('id badge') || lowerDesc.includes('identification')) {
                    createNameBadge(ctx, width, height, lowerDesc);
                } else if (lowerDesc.includes('border') || lowerDesc.includes('frame') || lowerDesc.includes('avatar border') || lowerDesc.includes('profile frame')) {
                    createAvatarBorder(ctx, width, height, lowerDesc);
                } else if (lowerDesc.includes('banner') || lowerDesc.includes('header') || lowerDesc.includes('background') || lowerDesc.includes('pattern')) {
                    createBanner(ctx, width, height, lowerDesc);
                } else if (lowerDesc.includes('shield') || lowerDesc.includes('crest') || lowerDesc.includes('seal') || lowerDesc.includes('stamp')) {
                    createShield(ctx, width, height, lowerDesc);
                } else if (lowerDesc.includes('cartoon') || lowerDesc.includes('chibi') || lowerDesc.includes('anime') || lowerDesc.includes('manga') || 
                          lowerDesc.includes('sketch') || lowerDesc.includes('drawing') || lowerDesc.includes('painting') || lowerDesc.includes('watercolor') ||
                          lowerDesc.includes('pixel art') || lowerDesc.includes('vector art') || lowerDesc.includes('stylized') || lowerDesc.includes('artistic') ||
                          lowerDesc.includes('caricature')) {
                    createArtStyle(ctx, width, height, lowerDesc);
                } else if (isPokerRelated) {
                    // Create poker-themed graphics based on description
                    if (lowerDesc.includes('card back') || lowerDesc.includes('playing card')) {
                        createCardBack(ctx, width, height);
                    } else if (lowerDesc.includes('chip') || lowerDesc.includes('poker chip')) {
                        createPokerChip(ctx, width, height);
                    } else if (lowerDesc.includes('avatar') && lowerDesc.includes('poker')) {
                        createPlayerAvatar(ctx, width, height);
                    } else if (lowerDesc.includes('table') && (lowerDesc.includes('poker') || lowerDesc.includes('felt'))) {
                        createTableFelt(ctx, width, height);
                    } else if (lowerDesc.includes('suit') && (lowerDesc.includes('card') || lowerDesc.includes('spade') || lowerDesc.includes('heart') || lowerDesc.includes('diamond') || lowerDesc.includes('club'))) {
                        createCardSuit(ctx, width, height, lowerDesc);
                    } else {
                        createPokerLogo(ctx, width, height);
                    }
                } else {
                    // Create general logo for non-poker requests
                    createGeneralLogo(ctx, width, height, lowerDesc);
                }

                // Convert canvas to image data URL
                const imageData = canvas.toDataURL('image/png');

                // Show the canvas
                canvas.style.display = 'block';

                // Determine asset type and if it's downloadable
                const assetType = getAssetType(lowerDesc);
                const isDownloadable = !isPokerRelated; // Non-poker assets are downloadable

                // Create download filename
                const filename = `${assetType.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}.png`;

                // Add logo message with image and download option
                const logoMessage = {
                    content: `${assetType} created successfully!${isDownloadable ? ' Download link available below.' : ' Ready for poker game integration.'}`,
                    isUser: false,
                    timestamp: new Date().toISOString(),
                    isApproval: true,
                    assetId: Date.now(),
                    imageUrl: imageData,
                    assetType: assetType,
                    type: 'image',
                    isDownloadable: isDownloadable,
                    downloadUrl: isDownloadable ? imageData : null,
                    filename: filename
                };

                setPendingAssets(prev => [...prev, logoMessage]);
                setMessages(prev => [...prev, logoMessage]);
                
                setMessages(prev => [...prev, approvalMessage]);
            };
            
            const getAssetType = (desc) => {
                if (desc.includes('card back')) return 'Card Back';
                if (desc.includes('poker chip') || desc.includes('chip') && desc.includes('poker')) return 'Poker Chip';
                if (desc.includes('avatar') && desc.includes('poker')) return 'Poker Avatar';
                if (desc.includes('table') && (desc.includes('poker') || desc.includes('felt'))) return 'Poker Table';
                if (desc.includes('suit') && (desc.includes('card') || desc.includes('spade') || desc.includes('heart') || desc.includes('diamond') || desc.includes('club'))) return 'Card Suit';
                if (desc.includes('badge') || desc.includes('nametag') || desc.includes('id badge')) return 'Name Badge';
                if (desc.includes('border') || desc.includes('frame') || desc.includes('avatar border')) return 'Avatar Border';
                if (desc.includes('banner') || desc.includes('header') || desc.includes('background')) return 'Banner';
                if (desc.includes('shield') || desc.includes('crest') || desc.includes('seal') || desc.includes('stamp')) return 'Shield/Crest';
                if (desc.includes('cartoon')) return 'Cartoon';
                if (desc.includes('chibi')) return 'Chibi';
                if (desc.includes('anime')) return 'Anime';
                if (desc.includes('manga')) return 'Manga';
                if (desc.includes('sketch')) return 'Sketch';
                if (desc.includes('drawing')) return 'Drawing';
                if (desc.includes('painting')) return 'Painting';
                if (desc.includes('watercolor')) return 'Watercolor';
                if (desc.includes('pixel art')) return 'Pixel Art';
                if (desc.includes('vector art')) return 'Vector Art';
                if (desc.includes('stylized')) return 'Stylized Art';
                if (desc.includes('artistic')) return 'Artistic';
                if (desc.includes('caricature')) return 'Caricature';
                if (desc.includes('logo') || desc.includes('icon') || desc.includes('emblem') || desc.includes('symbol')) return 'Logo';
                if (desc.includes('emote') || desc.includes('emoji') || desc.includes('face')) return 'Emote';
                return 'Image';
            };
            
            const createNameBadge = (ctx, width, height, description) => {
                // Background
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.strokeRect(10, 10, width - 20, height - 20);
                
                // Inner border
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(15, 15, width - 30, height - 30);
                
                // Badge shape (rounded corners effect)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(20, 20, width - 40, height - 40);
                
                // Text area
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('NAME BADGE', width / 2, 50);
                
                ctx.font = '14px Arial';
                ctx.fillText('Your Name', width / 2, 80);
                
                ctx.font = '12px Arial';
                ctx.fillText('ID: 123456', width / 2, 100);
                
                // Decorative elements
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(width / 2, 130, 8, 0, Math.PI * 2);
                ctx.fill();
            };
            
            const createAvatarBorder = (ctx, width, height, description) => {
                // Transparent center
                ctx.clearRect(0, 0, width, height);
                
                // Outer border with gradient
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, '#ff6b6b');
                gradient.addColorStop(0.5, '#4ecdc4');
                gradient.addColorStop(1, '#45b7d1');
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 15;
                ctx.strokeRect(7.5, 7.5, width - 15, height - 15);
                
                // Inner border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.strokeRect(12, 12, width - 24, height - 24);
                
                // Corner decorations
                const cornerSize = 20;
                ctx.fillStyle = '#ffd700';
                
                // Top-left corner
                ctx.fillRect(0, 0, cornerSize, 5);
                ctx.fillRect(0, 0, 5, cornerSize);
                
                // Top-right corner
                ctx.fillRect(width - cornerSize, 0, cornerSize, 5);
                ctx.fillRect(width - 5, 0, 5, cornerSize);
                
                // Bottom-left corner
                ctx.fillRect(0, height - 5, cornerSize, 5);
                ctx.fillRect(0, height - cornerSize, 5, cornerSize);
                
                // Bottom-right corner
                ctx.fillRect(width - cornerSize, height - 5, cornerSize, 5);
                ctx.fillRect(width - 5, height - cornerSize, 5, cornerSize);
            };
            
            const createBanner = (ctx, width, height, description) => {
                // Background gradient
                const gradient = ctx.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, '#1e3c72');
                gradient.addColorStop(0.5, '#2a5298');
                gradient.addColorStop(1, '#1e3c72');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Wave pattern
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let x = 0; x <= width; x += 10) {
                    const y = height / 2 + Math.sin(x * 0.1) * 20;
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BANNER', width / 2, height / 2 - 10);
                
                ctx.font = '14px Arial';
                ctx.fillText('Your Text Here', width / 2, height / 2 + 15);
                
                // Decorative stars
                ctx.fillStyle = '#ffd700';
                for (let i = 0; i < 5; i++) {
                    const x = (i + 1) * (width / 6);
                    const y = 20;
                    drawStar(ctx, x, y, 5, 8, 4);
                }
            };
            
            const createShield = (ctx, width, height, description) => {
                // Shield shape
                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.moveTo(width / 2, 20);
                ctx.lineTo(width - 20, 40);
                ctx.lineTo(width - 20, height / 2);
                ctx.quadraticCurveTo(width - 20, height - 20, width / 2, height - 10);
                ctx.quadraticCurveTo(20, height - 20, 20, height / 2);
                ctx.lineTo(20, 40);
                ctx.closePath();
                ctx.fill();
                
                // Border
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Inner shield
                ctx.fillStyle = '#34495e';
                ctx.beginPath();
                ctx.moveTo(width / 2, 30);
                ctx.lineTo(width - 30, 45);
                ctx.lineTo(width - 30, height / 2);
                ctx.quadraticCurveTo(width - 30, height - 30, width / 2, height - 20);
                ctx.quadraticCurveTo(30, height - 30, 30, height / 2);
                ctx.lineTo(30, 45);
                ctx.closePath();
                ctx.fill();
                
                // Cross emblem
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(width / 2, 50);
                ctx.lineTo(width / 2, height - 40);
                ctx.moveTo(width / 2 - 20, height / 2 - 10);
                ctx.lineTo(width / 2 + 20, height / 2 - 10);
                ctx.stroke();
                
                // Center circle
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(width / 2, height / 2 - 10, 12, 0, Math.PI * 2);
                ctx.fill();
            };
            
            const drawStar = (ctx, cx, cy, spikes, outerRadius, innerRadius) => {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / spikes;
                
                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                    
                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
                ctx.fill();
            };
            
            const createArtStyle = (ctx, width, height, description) => {
                // Check if there are uploaded reference images
                const referenceImages = uploadedFiles.filter(file => file.type === 'image');
                const hasReference = referenceImages.length > 0;
                
                // Extract art style from description
                const artStyle = extractArtStyle(description);
                
                if (hasReference && referenceImages[0]) {
                    // Create art style based on reference
                    createArtStyleFromReference(ctx, width, height, description, referenceImages[0], artStyle);
                } else {
                    // Create sample art style
                    createSampleArtStyle(ctx, width, height, artStyle);
                }
            };
            
            const extractArtStyle = (description) => {
                const styles = {
                    'cartoon': ['cartoon'],
                    'chibi': ['chibi'],
                    'anime': ['anime'],
                    'manga': ['manga'],
                    'sketch': ['sketch', 'drawing'],
                    'painting': ['painting'],
                    'watercolor': ['watercolor'],
                    'pixel art': ['pixel art'],
                    'vector art': ['vector art'],
                    'stylized': ['stylized'],
                    'artistic': ['artistic'],
                    'caricature': ['caricature']
                };
                
                const lowerDesc = description.toLowerCase();
                for (const [style, keywords] of Object.entries(styles)) {
                    if (keywords.some(keyword => lowerDesc.includes(keyword))) {
                        return style;
                    }
                }
                return 'cartoon'; // default style
            };
            
            const createArtStyleFromReference = (ctx, width, height, description, referenceImage, artStyle) => {
                // Create a styled version based on reference image
                // For now, we'll create a styled representation with reference indicator
                
                // Load reference image
                const img = new Image();
                img.onload = function() {
                    drawStyledArt(ctx, width, height, img, artStyle);
                };
                img.src = referenceImage.url;
            };
            
            const createSampleArtStyle = (ctx, width, height, artStyle) => {
                // Create sample art style without reference
                drawStyledArt(ctx, width, height, null, artStyle);
            };
            
            const drawStyledArt = (ctx, width, height, referenceImage, artStyle) => {
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                switch(artStyle) {
                    case 'cartoon':
                        drawCartoonStyle(ctx, width, height, referenceImage);
                        break;
                    case 'chibi':
                        drawChibiStyle(ctx, width, height, referenceImage);
                        break;
                    case 'anime':
                        drawAnimeStyle(ctx, width, height, referenceImage);
                        break;
                    case 'sketch':
                        drawSketchStyle(ctx, width, height, referenceImage);
                        break;
                    case 'pixel art':
                        drawPixelArtStyle(ctx, width, height, referenceImage);
                        break;
                    case 'watercolor':
                        drawWatercolorStyle(ctx, width, height, referenceImage);
                        break;
                    default:
                        drawCartoonStyle(ctx, width, height, referenceImage);
                }
            };
            
            const drawCartoonStyle = (ctx, width, height, referenceImage) => {
                // Cartoon style with bold outlines and bright colors
                if (referenceImage) {
                    // Draw reference image with cartoon effect
                    ctx.drawImage(referenceImage, 20, 20, width - 40, height - 40);
                    
                    // Add cartoon outline effect
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(20, 20, width - 40, height - 40);
                    
                    // Add bright colors overlay
                    ctx.fillStyle = 'rgba(255, 200, 0, 0.2)';
                    ctx.fillRect(20, 20, width - 40, height - 40);
                } else {
                    // Sample cartoon character
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(width/2, height/2 - 20, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FFB6C1';
                    ctx.beginPath();
                    ctx.arc(width/2, height/2 + 30, 50, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cartoon eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(width/2 - 15, height/2 - 25, 5, 0, Math.PI * 2);
                    ctx.arc(width/2 + 15, height/2 - 25, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cartoon smile
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(width/2, height/2 - 10, 20, 0, Math.PI);
                    ctx.stroke();
                }
                
                // Add style label
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('CARTOON STYLE', width/2, height - 10);
            };
            
            const drawChibiStyle = (ctx, width, height, referenceImage) => {
                // Chibi style - cute, small proportions
                if (referenceImage) {
                    ctx.drawImage(referenceImage, 30, 30, width - 60, height - 60);
                } else {
                    // Sample chibi character
                    ctx.fillStyle = '#FFE4E1';
                    ctx.beginPath();
                    ctx.arc(width/2, height/2 - 10, 35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FFC0CB';
                    ctx.beginPath();
                    ctx.arc(width/2, height/2 + 40, 30, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Big chibi eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(width/2 - 10, height/2 - 15, 8, 0, Math.PI * 2);
                    ctx.arc(width/2 + 10, height/2 - 15, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Small mouth
                    ctx.beginPath();
                    ctx.arc(width/2, height/2, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add style label
                ctx.fillStyle = '#FF69B4';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('CHIBI STYLE', width/2, height - 10);
            };
            
            const drawAnimeStyle = (ctx, width, height, referenceImage) => {
                // Anime style with characteristic features
                if (referenceImage) {
                    ctx.drawImage(referenceImage, 25, 25, width - 50, height - 50);
                } else {
                    // Sample anime character
                    ctx.fillStyle = '#FDBCB4';
                    ctx.beginPath();
                    ctx.arc(width/2, height/2 - 10, 45, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Large anime eyes
                    ctx.fillStyle = '#4169E1';
                    ctx.beginPath();
                    ctx.ellipse(width/2 - 15, height/2 - 15, 12, 15, 0, 0, Math.PI * 2);
                    ctx.ellipse(width/2 + 15, height/2 - 15, 12, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye highlights
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(width/2 - 12, height/2 - 18, 4, 0, Math.PI * 2);
                    ctx.arc(width/2 + 18, height/2 - 18, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Small mouth
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(width/2 - 5, height/2 + 10);
                    ctx.lineTo(width/2 + 5, height/2 + 10);
                    ctx.stroke();
                }
                
                // Add style label
                ctx.fillStyle = '#FF1493';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ANIME STYLE', width/2, height - 10);
            };
            
            const drawSketchStyle = (ctx, width, height, referenceImage) => {
                // Sketch style with hand-drawn appearance
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                
                if (referenceImage) {
                    // Draw reference with sketch effect
                    ctx.globalAlpha = 0.7;
                    ctx.drawImage(referenceImage, 20, 20, width - 40, height - 40);
                    ctx.globalAlpha = 1.0;
                    
                    // Add sketch lines
                    for (let i = 0; i < 20; i++) {
                        ctx.beginPath();
                        ctx.moveTo(Math.random() * width, Math.random() * height);
                        ctx.lineTo(Math.random() * width, Math.random() * height);
                        ctx.stroke();
                    }
                } else {
                    // Sample sketch
                    ctx.beginPath();
                    ctx.arc(width/2, height/2, 60, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Sketchy eyes
                    ctx.beginPath();
                    ctx.arc(width/2 - 20, height/2 - 10, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(width/2 + 20, height/2 - 10, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Sketchy mouth
                    ctx.beginPath();
                    ctx.moveTo(width/2 - 20, height/2 + 20);
                    ctx.quadraticCurveTo(width/2, height/2 + 30, width/2 + 20, height/2 + 20);
                    ctx.stroke();
                }
                
                // Add style label
                ctx.fillStyle = '#666';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SKETCH STYLE', width/2, height - 10);
            };
            
            const drawPixelArtStyle = (ctx, width, height, referenceImage) => {
                // Pixel art style with blocky appearance
                const pixelSize = 8;
                
                if (referenceImage) {
                    // Create pixelated version
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(referenceImage, 0, 0, width, height);
                    ctx.imageSmoothingEnabled = true;
                } else {
                    // Sample pixel art character
                    const pixels = [
                        [0,0,1,1,1,1,0,0],
                        [0,1,2,2,2,2,1,0],
                        [1,2,3,2,2,3,2,1],
                        [1,2,2,2,2,2,2,1],
                        [1,2,4,2,2,4,2,1],
                        [1,2,2,2,2,2,2,1],
                        [0,1,5,5,5,5,1,0],
                        [0,0,1,1,1,1,0,0]
                    ];
                    
                    const colors = ['#FFF', '#000', '#FFD700', '#000', '#FF69B4', '#8B4513'];
                    
                    for (let y = 0; y < pixels.length; y++) {
                        for (let x = 0; x < pixels[y].length; x++) {
                            ctx.fillStyle = colors[pixels[y][x]];
                            ctx.fillRect(
                                (width/2 - 32) + x * pixelSize,
                                (height/2 - 32) + y * pixelSize,
                                pixelSize,
                                pixelSize
                            );
                        }
                    }
                }
                
                // Add style label
                ctx.fillStyle = '#00FF00';
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('PIXEL ART', width/2, height - 10);
            };
            
            const drawWatercolorStyle = (ctx, width, height, referenceImage) => {
                // Watercolor style with soft edges
                if (referenceImage) {
                    ctx.globalAlpha = 0.6;
                    ctx.drawImage(referenceImage, 20, 20, width - 40, height - 40);
                    ctx.globalAlpha = 1.0;
                } else {
                    // Sample watercolor effect
                    const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, 80);
                    gradient.addColorStop(0, 'rgba(255, 182, 193, 0.7)');
                    gradient.addColorStop(0.5, 'rgba(255, 218, 185, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(width/2, height/2, 70, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add watercolor splashes
                    ctx.fillStyle = 'rgba(135, 206, 235, 0.4)';
                    ctx.beginPath();
                    ctx.arc(width/2 - 30, height/2 - 20, 20, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(255, 182, 193, 0.4)';
                    ctx.beginPath();
                    ctx.arc(width/2 + 25, height/2 + 15, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add style label
                ctx.fillStyle = '#87CEEB';
                ctx.font = 'italic 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('WATERCOLOR', width/2, height - 10);
            };
            
            const createCardBack = (ctx, width, height) => {
                // Card back design
                const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
                gradient.addColorStop(0, '#2c3e50');
                gradient.addColorStop(0.5, '#34495e');
                gradient.addColorStop(1, '#2c3e50');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Add pattern
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(10, 10, width-20, height-20);
                
                // Inner border
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                ctx.strokeRect(20, 20, width-40, height-40);
                
                // Center design
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(width/2, height/2, 30, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#e74c3c';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚ô†Ô∏è', width/2, height/2 + 5);
            };
            
            const createPokerChip = (ctx, width, height) => {
                // Poker chip design
                const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
                gradient.addColorStop(0, '#e74c3c');
                gradient.addColorStop(0.7, '#c0392b');
                gradient.addColorStop(1, '#8b0000');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(width/2, height/2, width/2 - 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner circle
                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(width/2, height/2, width/2 - 25, 0, Math.PI * 2);
                ctx.fill();
                
                // Dollar sign
                ctx.fillStyle = '#f39c12';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('$', width/2, height/2 + 8);
                
                // Edge dots
                ctx.fillStyle = '#f39c12';
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI * 2) / 8;
                    const x = width/2 + Math.cos(angle) * (width/2 - 15);
                    const y = height/2 + Math.sin(angle) * (width/2 - 15);
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            };
            
            const createPlayerAvatar = (ctx, width, height) => {
                // Player avatar background
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Avatar circle
                ctx.fillStyle = '#f0f0f0';
                ctx.beginPath();
                ctx.arc(width/2, height/2, 60, 0, Math.PI * 2);
                ctx.fill();
                
                // Player icon
                ctx.fillStyle = '#333';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üë§', width/2, height/2 + 10);
                
                // Status indicator
                ctx.fillStyle = '#10b981';
                ctx.beginPath();
                ctx.arc(width - 30, 30, 8, 0, Math.PI * 2);
                ctx.fill();
            };
            
            const createTableFelt = (ctx, width, height) => {
                // Poker table felt
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#0d5f2b');
                gradient.addColorStop(0.5, '#0a4f2a');
                gradient.addColorStop(1, '#0d5f2b');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Wood texture lines
                ctx.strokeStyle = '#084420';
                ctx.lineWidth = 1;
                for (let i = 0; i < height; i += 10) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(width, i);
                    ctx.stroke();
                }
                
                // Center design
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 3;
                ctx.strokeRect(width/2 - 40, height/2 - 40, 80, 80);
            };
            
            const createCardSuit = (ctx, width, height, desc) => {
                let suit = '‚ô†Ô∏è';
                let color = '#000000';
                
                if (desc.includes('heart') || desc.includes('‚ô•')) {
                    suit = '‚ô•Ô∏è';
                    color = '#e74c3c';
                } else if (desc.includes('diamond') || desc.includes('‚ô¶')) {
                    suit = '‚ô¶Ô∏è';
                    color = '#e74c3c';
                } else if (desc.includes('club') || desc.includes('‚ô£')) {
                    suit = '‚ô£Ô∏è';
                    color = '#000000';
                }
                
                // Card background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);
                
                // Card border
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 2;
                ctx.strokeRect(5, 5, width-10, height-10);
                
                // Suit symbol
                ctx.fillStyle = color;
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(suit, width/2, height/2 + 20);
            };
            
            const createEmote = (ctx, width, height, description) => {
                // Check if there are uploaded reference images
                const referenceImages = uploadedFiles.filter(file => file.type === 'image');
                const hasReference = referenceImages.length > 0;
                
                // Extract name and theme from description
                const nameMatch = description.match(/(?:for|of|named?|called)\s+([a-zA-Z]+)/i);
                const personName = nameMatch ? nameMatch[1] : 'Person';
                const theme = extractTheme(description);
                
                if (hasReference && referenceImages[0]) {
                    // Create personalized emote based on reference
                    createPersonalizedEmote(ctx, width, height, description, referenceImages[0], personName, theme);
                } else {
                    // Create standard emote
                    createStandardEmote(ctx, width, height, description, personName, theme);
                }
            };
            
            const extractTheme = (description) => {
                const themes = {
                    'happy': ['happy', 'joy', 'smile', 'cheerful', 'glad'],
                    'cool': ['cool', 'awesome', 'swag', 'stylish', 'trendy'],
                    'sad': ['sad', 'cry', 'tear', 'unhappy', 'blue'],
                    'angry': ['angry', 'mad', 'rage', 'furious', 'upset'],
                    'surprised': ['surprised', 'shock', 'wow', 'amazed', 'astonished'],
                    'love': ['love', 'heart', 'adore', 'crush', 'romantic'],
                    'thinking': ['thinking', 'hmm', 'ponder', 'wonder', 'curious'],
                    'sleepy': ['sleepy', 'tired', 'yawn', 'drowsy', 'exhausted'],
                    'crazy': ['crazy', 'wild', 'insane', 'bonkers', 'wacky'],
                    'smart': ['smart', 'genius', 'brainy', 'intelligent', 'clever']
                };
                
                const lowerDesc = description.toLowerCase();
                for (const [theme, keywords] of Object.entries(themes)) {
                    if (keywords.some(keyword => lowerDesc.includes(keyword))) {
                        return theme;
                    }
                }
                return 'happy'; // default theme
            };
            
            const createPersonalizedEmote = (ctx, width, height, description, referenceImage, personName, theme) => {
                // Create a personalized emote that references the uploaded image
                // For now, we'll create a themed emote with the person's name
                
                // Background based on theme
                const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
                gradient.addColorStop(0, getThemeColor(theme));
                gradient.addColorStop(1, adjustThemeColor(getThemeColor(theme), -30));
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Face circle
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.arc(width/2, height/2, 80, 0, Math.PI * 2);
                ctx.fill();
                
                // Face border
                ctx.strokeStyle = getThemeColor(theme);
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Draw themed expression
                drawThemedExpression(ctx, width, height, theme);
                
                // Add person's name
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(personName, width/2, height - 15);
                
                // Add theme indicator
                ctx.fillStyle = getThemeColor(theme);
                ctx.font = '10px Arial';
                ctx.fillText(theme.toUpperCase(), width/2, height - 30);
                
                // Add reference indicator
                ctx.fillStyle = '#666';
                ctx.font = '8px Arial';
                ctx.fillText('üì∑ Based on reference', width/2, height - 5);
            };
            
            const createStandardEmote = (ctx, width, height, description, personName, theme) => {
                // Standard emote creation with person's name
                const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
                gradient.addColorStop(0, '#ffd700');
                gradient.addColorStop(1, '#ffb347');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.arc(width/2, height/2, 80, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#ff9800';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                drawThemedExpression(ctx, width, height, theme);
                
                // Add person's name
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(personName, width/2, height - 15);
                
                // Add theme indicator
                ctx.fillStyle = getThemeColor(theme);
                ctx.font = '10px Arial';
                ctx.fillText(theme.toUpperCase(), width/2, height - 30);
            };
            
            const getThemeColor = (theme) => {
                const colors = {
                    'happy': '#FFD700',
                    'cool': '#4FC3F7',
                    'love': '#FF1493',
                    'thinking': '#9C27B0',
                    'sad': '#64B5F6',
                    'angry': '#F44336',
                    'surprised': '#FF9800',
                    'sleepy': '#9E9E9E',
                    'crazy': '#E91E63',
                    'smart': '#4CAF50'
                };
                return colors[theme] || '#FFD700';
            };
            
            const adjustThemeColor = (color, amount) => {
                // Simple color adjustment function
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.max(0, Math.min(255, (num >> 16) + amount));
                const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
                const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            };
            
            const drawThemedExpression = (ctx, width, height, theme) => {
                ctx.fillStyle = '#000000';
                
                switch(theme) {
                    case 'happy':
                        // Happy eyes
                        ctx.beginPath();
                        ctx.arc(width/2 - 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(width/2 + 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Big smile
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(width/2, height/2 + 10, 40, 0, Math.PI);
                        ctx.stroke();
                        break;
                        
                    case 'cool':
                        // Sunglasses
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(width/2 - 40, height/2 - 30, 30, 20);
                        ctx.fillRect(width/2 + 10, height/2 - 30, 30, 20);
                        ctx.fillRect(width/2 - 10, height/2 - 25, 20, 5);
                        
                        // Cool smile
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(width/2 - 20, height/2 + 20);
                        ctx.quadraticCurveTo(width/2, height/2 + 30, width/2 + 20, height/2 + 20);
                        ctx.stroke();
                        break;
                        
                    case 'love':
                        // Heart eyes
                        ctx.fillStyle = '#e91e63';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚ù§Ô∏è', width/2 - 25, height/2 - 15);
                        ctx.fillText('‚ù§Ô∏è', width/2 + 25, height/2 - 15);
                        
                        // Love smile
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(width/2, height/2 + 10, 40, 0, Math.PI);
                        ctx.stroke();
                        break;
                        
                    case 'thinking':
                        // Thinking eyes
                        ctx.beginPath();
                        ctx.arc(width/2 - 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(width/2 + 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Thoughtful mouth
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(width/2 - 15, height/2 + 25);
                        ctx.lineTo(width/2 + 5, height/2 + 25);
                        ctx.stroke();
                        
                        // Thought bubble
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(width/2 + 60, height/2 - 40, 15, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'sad':
                        // Sad eyes
                        ctx.beginPath();
                        ctx.arc(width/2 - 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(width/2 + 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Sad mouth
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(width/2, height/2 + 40, 30, Math.PI, 0);
                        ctx.stroke();
                        break;
                        
                    case 'angry':
                        // Angry eyes
                        ctx.beginPath();
                        ctx.arc(width/2 - 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(width/2 + 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Angry eyebrows
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(width/2 - 35, height/2 - 35);
                        ctx.lineTo(width/2 - 15, height/2 - 25);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(width/2 + 35, height/2 - 35);
                        ctx.lineTo(width/2 + 15, height/2 - 25);
                        ctx.stroke();
                        
                        // Angry mouth
                        ctx.beginPath();
                        ctx.moveTo(width/2 - 20, height/2 + 30);
                        ctx.lineTo(width/2 + 20, height/2 + 30);
                        ctx.stroke();
                        break;
                        
                    case 'surprised':
                        // Surprised eyes
                        ctx.beginPath();
                        ctx.arc(width/2 - 25, height/2 - 20, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(width/2 + 25, height/2 - 20, 12, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Surprised mouth
                        ctx.beginPath();
                        ctx.arc(width/2, height/2 + 25, 20, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    default:
                        // Default happy face
                        ctx.beginPath();
                        ctx.arc(width/2 - 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(width/2 + 25, height/2 - 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(width/2, height/2 + 10, 40, 0, Math.PI);
                        ctx.stroke();
                }
            };
            
            const createGeneralLogo = (ctx, width, height, description) => {
                // General logo design based on description
                const lowerDesc = description.toLowerCase();
                
                // Background gradient
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // White background circle
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(width/2, height/2, 70, 0, Math.PI * 2);
                ctx.fill();
                
                // Icon based on description
                ctx.fillStyle = '#667eea';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (lowerDesc.includes('helm') || lowerDesc.includes('shield')) {
                    ctx.fillText('üõ°Ô∏è', width/2, height/2);
                } else if (lowerDesc.includes('tech') || lowerDesc.includes('code')) {
                    ctx.fillText('üíª', width/2, height/2);
                } else if (lowerDesc.includes('star') || lowerDesc.includes('rating')) {
                    ctx.fillText('‚≠ê', width/2, height/2);
                } else if (lowerDesc.includes('heart') || lowerDesc.includes('love')) {
                    ctx.fillText('‚ù§Ô∏è', width/2, height/2);
                } else if (lowerDesc.includes('fire') || lowerDesc.includes('hot')) {
                    ctx.fillText('üî•', width/2, height/2);
                } else if (lowerDesc.includes('lightning') || lowerDesc.includes('bolt')) {
                    ctx.fillText('‚ö°', width/2, height/2);
                } else if (lowerDesc.includes('rocket') || lowerDesc.includes('launch')) {
                    ctx.fillText('üöÄ', width/2, height/2);
                } else if (lowerDesc.includes('crown') || lowerDesc.includes('king')) {
                    ctx.fillText('üëë', width/2, height/2);
                } else if (lowerDesc.includes('diamond') || lowerDesc.includes('gem')) {
                    ctx.fillText('üíé', width/2, height/2);
                } else {
                    // Default Helm logo
                    ctx.fillText('üõ°Ô∏è', width/2, height/2);
                }
                
                // Text label
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('HELM', width/2, height - 20);
            };
            
            const createPokerLogo = (ctx, width, height) => {
                // Poker logo design
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#16213e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Cards background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(20, 20, width-40, height-40);
                
                // Playing cards
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(30, 40, 40, 60);
                ctx.fillRect(130, 40, 40, 60);
                
                // Card suits
                ctx.fillStyle = '#e74c3c';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚ô•Ô∏è', 50, 70);
                ctx.fillText('‚ô†Ô∏è', 150, 70);
                
                // Poker chips
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(50, 120, 20, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(100, 120, 20, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(150, 120, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Title
                ctx.fillStyle = '#667eea';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('POKER', width/2, height - 25);
            };
            
            const createAudio = (description) => {
                const lowerDesc = description.toLowerCase();
                
                if (lowerDesc.includes('card shuffle') || lowerDesc.includes('shuffle')) {
                    createCardShuffleSound();
                } else if (lowerDesc.includes('chip sound') || lowerDesc.includes('chip noise')) {
                    createChipSound();
                } else if (lowerDesc.includes('win') || lowerDesc.includes('victory')) {
                    createWinSound();
                } else if (lowerDesc.includes('lose') || lowerDesc.includes('defeat')) {
                    createLoseSound();
                } else if (lowerDesc.includes('deal') || lowerDesc.includes('dealing')) {
                    createDealSound();
                } else if (lowerDesc.includes('bet') || lowerDesc.includes('wager')) {
                    createBetSound();
                } else if (lowerDesc.includes('background') || lowerDesc.includes('music') || lowerDesc.includes('ambient')) {
                    createBackgroundMusic();
                } else if (lowerDesc.includes('alert') || lowerDesc.includes('notification')) {
                    createAlertSound();
                } else {
                    createBackgroundMusic(); // Default
                }
                
                // Create pending asset for approval
                const pendingAsset = {
                    id: Date.now(),
                    type: 'audio',
                    assetType: getAudioType(lowerDesc),
                    description: description,
                    audioUrl: currentAudioUrl,
                    timestamp: new Date().toISOString(),
                    status: 'pending'
                };
                
                setPendingAssets(prev => [...prev, pendingAsset]);
                
                // Add approval message
                const approvalMessage = {
                    content: `Poker ${getAudioType(lowerDesc)} created! Review and approve to implement:`,
                    isUser: false,
                    timestamp: new Date().toISOString(),
                    isApproval: true,
                    assetId: pendingAsset.id,
                    audioUrl: currentAudioUrl
                };
                
                setMessages(prev => [...prev, approvalMessage]);
            };
            
            const getAudioType = (desc) => {
                if (desc.includes('shuffle')) return 'Shuffle Sound';
                if (desc.includes('chip')) return 'Chip Sound';
                if (desc.includes('win')) return 'Win Sound';
                if (desc.includes('lose')) return 'Lose Sound';
                if (desc.includes('deal')) return 'Deal Sound';
                if (desc.includes('bet')) return 'Bet Sound';
                if (desc.includes('background') || desc.includes('music')) return 'Background Music';
                if (desc.includes('alert') || desc.includes('notification')) return 'Alert Sound';
                return 'Audio';
            };
            
            let currentAudioUrl = null;
            
            // Audio generation functions
            const createCardShuffleSound = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 1.5;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, sampleRate * duration, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Create realistic card shuffle sound
                    if (Math.random() < 0.02) {
                        data[i] = (Math.random() - 0.5) * 0.3; // Random noise
                    } else {
                        data[i] = Math.sin(i * 0.02) * 0.1 * Math.exp(-i * 0.001) * Math.random();
                    }
                }
                
                const blob = new Blob([buffer], { type: 'audio/wav' });
                currentAudioUrl = URL.createObjectURL(blob);
            };
            
            const createChipSound = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 0.3;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, sampleRate * duration, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Create chip click sound
                    data[i] = Math.sin(i * 0.5) * 0.8 * Math.exp(-i * 0.01);
                }
                
                const blob = new Blob([buffer], { type: 'audio/wav' });
                currentAudioUrl = URL.createObjectURL(blob);
            };
            
            const createWinSound = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 2.0;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, sampleRate * duration, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Create celebratory win sound
                    const t = i / sampleRate;
                    data[i] = (Math.sin(440 * t) * 0.3 + Math.sin(880 * t) * 0.2) * Math.exp(-t * 0.5) +
                              (Math.sin(220 * t) * 0.4 + Math.sin(660 * t) * 0.3) * Math.exp(-t * 0.3);
                }
                
                const blob = new Blob([buffer], { type: 'audio/wav' });
                currentAudioUrl = URL.createObjectURL(blob);
            };
            
            const createLoseSound = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 1.0;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, sampleRate * duration, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Create sad lose sound
                    const t = i / sampleRate;
                    data[i] = (Math.sin(200 * t) * 0.2 * Math.exp(-t * 0.8)) +
                              (Math.sin(100 * t) * 0.1 * Math.exp(-t * 0.5));
                }
                
                const blob = new Blob([buffer], { type: 'audio/wav' });
                currentAudioUrl = URL.createObjectURL(blob);
            };
            
            const createDealSound = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 0.8;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, sampleRate * duration, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Create card dealing sound
                    if (i < 100) {
                        data[i] = Math.random() * 0.1 - 0.05; // Quick swoosh
                    } else {
                        data[i] = 0;
                    }
                }
                
                const blob = new Blob([buffer], { type: 'audio/wav' });
                currentAudioUrl = URL.createObjectURL(blob);
            };
            
            const createBetSound = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 0.4;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, sampleRate * duration, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Create bet placement sound
                    data[i] = Math.sin(i * 0.8) * 0.3 * Math.exp(-i * 0.01);
                }
                
                const blob = new Blob([buffer], { type: 'audio/wav' });
                currentAudioUrl = URL.createObjectURL(blob);
            };
            
            const createBackgroundMusic = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 10.0;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, sampleRate * duration, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Create ambient poker background music
                    const t = i / sampleRate;
                    data[i] = (Math.sin(110 * t) * 0.1 + Math.sin(220 * t) * 0.05) * 0.3 +
                              (Math.sin(330 * t) * 0.08 * 0.2) +
                              (Math.sin(440 * t) * 0.06 * 0.15);
                }
                
                const blob = new Blob([buffer], { type: 'audio/wav' });
                currentAudioUrl = URL.createObjectURL(blob);
            };
            
            const createAlertSound = () => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const duration = 0.5;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, sampleRate * duration, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Create alert notification sound
                    const t = i / sampleRate;
                    data[i] = Math.sin(880 * t) * 0.2 * Math.exp(-t * 0.3);
                }
                
                const blob = new Blob([buffer], { type: 'audio/wav' });
                currentAudioUrl = URL.createObjectURL(blob);
            };
            
            const approveAsset = (assetId) => {
                const asset = pendingAssets.find(a => a.id === assetId);
                if (!asset) return;
                
                // Implement the asset
                implementAsset(asset);
                
                // Update status
                setPendingAssets(prev => prev.map(a => 
                    a.id === assetId ? { ...a, status: 'approved' } : a
                ));
                
                // Add implementation message
                const implMessage = {
                    content: `‚úÖ ${asset.assetType} approved and implemented!`,
                    isUser: false,
                    timestamp: new Date().toISOString(),
                    isImplementation: true,
                    assetId: assetId
                };
                
                setMessages(prev => [...prev, implMessage]);
            };
            
            const rejectAsset = (assetId) => {
                // Update status
                setPendingAssets(prev => prev.map(a => 
                    a.id === assetId ? { ...a, status: 'rejected' } : a
                ));
                
                // Add rejection message
                const rejectMessage = {
                    content: `‚ùå Asset rejected. You can create a new one if needed.`,
                    isUser: false,
                    timestamp: new Date().toISOString(),
                    isImplementation: true,
                    assetId: assetId
                };
                
                setMessages(prev => [...prev, rejectMessage]);
            };
            
            const implementAsset = async (asset) => {
                try {
                    // Simulate implementation (in real scenario, this would save files)
                    console.log('Implementing asset:', asset);
                    
                    // For demonstration, we'll just show what would happen
                    const implementationDetails = {
                        image: {
                            folder: `assets/${asset.assetType.toLowerCase().replace(' ', '-')}/`,
                            filename: `${asset.assetType.toLowerCase().replace(' ', '-')}-${Date.now()}.png`,
                            component: `components/${asset.assetType.replace(' ', '')}.jsx`,
                            styles: `styles/${asset.assetType.toLowerCase().replace(' ', '')}.css`
                        },
                        audio: {
                            folder: `assets/audio/`,
                            filename: `${asset.assetType.toLowerCase().replace(' ', '-')}-${Date.now()}.wav`,
                            component: `components/AudioPlayer.jsx`,
                            integration: 'integrated with game sound system'
                        }
                    };
                    
                    const details = implementationDetails[asset.type];
                    
                    // Add detailed implementation message
                    const detailMessage = {
                        content: `üìÅ Implementation Details:\n‚Ä¢ Saved to: ${details.folder}\n‚Ä¢ Filename: ${details.filename}\n‚Ä¢ Component: ${details.component}\n‚Ä¢ Ready to use in your poker game!`,
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isImplementation: true,
                        assetId: asset.id
                    };
                    
                    setTimeout(() => {
                        setMessages(prev => [...prev, detailMessage]);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Implementation error:', error);
                }
            };
            
            // File upload functions
            const handleFileUpload = (files) => {
                // Security: Validate file types and sizes
                const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/ogg'];
                const maxFileSize = 10 * 1024 * 1024; // 10MB limit
                const maxTotalSize = 50 * 1024 * 1024; // 50MB total limit
                
                const validFiles = Array.from(files).filter(file => {
                    // Security: Check file type
                    if (!validTypes.includes(file.type)) {
                        console.warn(`Rejected file type: ${file.type}`);
                        return false;
                    }
                    
                    // Security: Check file size
                    if (file.size > maxFileSize) {
                        console.warn(`Rejected file size: ${file.size} bytes`);
                        return false;
                    }
                    
                    // Security: Check file name for suspicious patterns
                    const suspiciousPatterns = [/\.(exe|bat|cmd|scr|php|jsp|asp|sh|py)$/i, /<script/i, /javascript:/i];
                    if (suspiciousPatterns.some(pattern => pattern.test(file.name))) {
                        console.warn(`Rejected suspicious filename: ${file.name}`);
                        return false;
                    }
                    
                    return true;
                });
                
                if (validFiles.length === 0) {
                    const errorMessage = {
                        content: 'üö´ Security Alert: No valid files uploaded. Please upload only images (JPG, PNG, GIF, WebP) or audio files (WAV, MP3, OGG) under 10MB each.',
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isError: true
                    };
                    setMessages(prev => [...prev, errorMessage]);
                    return;
                }
                
                // Security: Check total upload size
                const currentTotalSize = uploadedFiles.reduce((total, file) => total + (file.size || 0), 0);
                const newTotalSize = currentTotalSize + validFiles.reduce((total, file) => total + file.size, 0);
                
                if (newTotalSize > maxTotalSize) {
                    const errorMessage = {
                        content: `üö´ Security Alert: Total upload size exceeds 50MB limit. Current: ${(currentTotalSize / 1024 / 1024).toFixed(2)}MB, Attempted: ${(newTotalSize / 1024 / 1024).toFixed(2)}MB`,
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isError: true
                    };
                    setMessages(prev => [...prev, errorMessage]);
                    return;
                }
                
                // Security: Sanitize file information
                const newFiles = validFiles.map(file => {
                    const fileId = Date.now() + Math.random();
                    const sanitizedUrl = URL.createObjectURL(file);
                    
                    return {
                        id: fileId,
                        file: file,
                        name: sanitizeFileName(file.name),
                        type: file.type.startsWith('image/') ? 'image' : 'audio',
                        url: sanitizedUrl,
                        size: file.size,
                        timestamp: new Date().toISOString(),
                        checksum: generateSimpleChecksum(file.name + file.size + file.type)
                    };
                });
                
                setUploadedFiles(prev => [...prev, ...newFiles]);
                
                // Security: Log upload for audit
                console.log('üîí Secure upload completed:', {
                    files: newFiles.map(f => ({
                        name: f.name,
                        type: f.type,
                        size: f.size,
                        checksum: f.checksum
                    })),
                    timestamp: new Date().toISOString()
                });
                
                // Add secure upload confirmation message
                const uploadMessage = {
                    content: `üîí Files uploaded securely:\n${newFiles.map(f => `‚Ä¢ ${f.name} (${formatFileSize(f.size)})`).join('\n')}\n\nüìä Total storage: ${(newTotalSize / 1024 / 1024).toFixed(2)}MB / 50MB\n\nYou can now reference these files when creating new assets!`,
                    isUser: false,
                    timestamp: new Date().toISOString(),
                    isUpload: true
                };
                
                setMessages(prev => [...prev, uploadMessage]);
            };
            
            // Security: Sanitize file names
            const sanitizeFileName = (fileName) => {
                return fileName
                    .replace(/[<>:"/\\|?*]/g, '_') // Remove invalid characters
                    .replace(/\s+/g, '_') // Replace spaces with underscores
                    .substring(0, 100); // Limit length
            };
            
            // Security: Generate simple checksum for file integrity
            const generateSimpleChecksum = (data) => {
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    const char = data.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash.toString(16);
            };
            
            // Security: Scan uploaded files for potential threats
            const scanFileForThreats = (file) => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        const content = e.target.result;
                        
                        // Basic threat detection patterns
                        const threatPatterns = [
                            /<script[^>]*>.*?<\/script>/gi,
                            /javascript:/gi,
                            /vbscript:/gi,
                            /on\w+\s*=/gi,
                            /<iframe[^>]*>/gi,
                            /<object[^>]*>/gi,
                            /<embed[^>]*>/gi
                        ];
                        
                        const hasThreat = threatPatterns.some(pattern => pattern.test(content));
                        resolve(!hasThreat);
                    };
                    
                    reader.onerror = () => resolve(false);
                    reader.readAsText(file.slice(0, 1024)); // Only read first 1KB for scanning
                });
            };
            
            const handleDragOver = (e) => {
                e.preventDefault();
                setIsDragging(true);
            };
            
            const handleDragLeave = (e) => {
                e.preventDefault();
                setIsDragging(false);
            };
            
            const handleDrop = (e) => {
                e.preventDefault();
                setIsDragging(false);
                handleFileUpload(e.dataTransfer.files);
            };
            
            const removeUploadedFile = (fileId) => {
                setUploadedFiles(prev => prev.filter(f => f.id !== fileId));
            };
            
            const formatFileSize = (bytes) => {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            };
            
            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    
                    if (confirmationMode) {
                        // Handle confirmation answer
                        handleConfirmationAnswer(input);
                        setInput('');
                    } else {
                        sendMessage();
                    }
                }
            };
            
            // Download functionality
            const downloadAsset = (asset) => {
                if (!asset.downloadUrl || !asset.isDownloadable) return;
                
                try {
                    // Create a temporary link element
                    const link = document.createElement('a');
                    link.href = asset.downloadUrl;
                    link.download = asset.filename;
                    link.style.display = 'none';
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Add success message
                    const downloadMessage = {
                        content: `üì• ${asset.assetType} downloaded successfully as ${asset.filename}`,
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isDownload: true
                    };
                    
                    setMessages(prev => [...prev, downloadMessage]);
                } catch (error) {
                    console.error('Download failed:', error);
                    
                    // Add error message
                    const errorMessage = {
                        content: `‚ùå Download failed. Please try again.`,
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isError: true
                    };
                    
                    setMessages(prev => [...prev, errorMessage]);
                }
            };
            
            // Performance optimizations
            const debounce = (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            };
            
            // Throttled input handler for better performance
            const throttle = (func, limit) => {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            };
            
            // Memory cleanup for uploaded files
            const cleanupOldFiles = () => {
                const now = Date.now();
                const maxAge = 30 * 60 * 1000; // 30 minutes
                
                setUploadedFiles(prev => prev.filter(file => 
                    now - new Date(file.timestamp).getTime() < maxAge
                ));
            };
            
            // Auto-cleanup every 5 minutes
            setInterval(cleanupOldFiles, 5 * 60 * 1000);
            
            // Resource monitoring
            const monitorResources = () => {
                if (performance.memory) {
                    const memory = performance.memory;
                    const used = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
                    
                    // Clean up if memory usage is high
                    if (used > 80) {
                        console.log('üßπ High memory usage detected, cleaning up...');
                        cleanupOldFiles();
                        
                        // Clear old messages if too many
                        setMessages(prev => prev.slice(-50));
                        
                        // Clear canvas cache
                        const canvas = document.getElementById('logo-canvas');
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    }
                }
            };
            
            // Monitor resources every 30 seconds
            setInterval(monitorResources, 30 * 1000);
            
            // Lazy loading for images
            const lazyLoadImage = (src, callback) => {
                const img = new Image();
                img.loading = 'lazy';
                
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            img.src = src;
                            observer.unobserve(img.target);
                        }
                    });
                });
                
                img.onload = callback;
                observer.observe(img);
                return img;
            };
            
            // Efficient canvas operations
            const createOptimizedCanvas = (width, height) => {
                const canvas = document.getElementById('logo-canvas');
                if (!canvas) return null;
                
                // Only resize if necessary
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                }
                
                return canvas;
            };
            
            // Cache for frequently used patterns
            const patternCache = new Map();
            
            const getCachedPattern = (key, createPattern) => {
                if (!patternCache.has(key)) {
                    patternCache.set(key, createPattern());
                }
                return patternCache.get(key);
            };
            
            // Batch DOM operations
            const batchDOMUpdates = [];
            let batchTimeout;
            
            const scheduleDOMUpdate = (updateFn) => {
                batchDOMUpdates.push(updateFn);
                
                if (!batchTimeout) {
                    batchTimeout = setTimeout(() => {
                        requestAnimationFrame(() => {
                            batchDOMUpdates.forEach(fn => fn());
                            batchDOMUpdates.length = 0;
                        });
                        batchTimeout = null;
                    }, 16); // ~60fps
                }
            };
            
            // Optimized color calculations
            const colorCache = new Map();
            
            const getCachedColor = (colorString) => {
                if (!colorCache.has(colorString)) {
                    const tempDiv = document.createElement('div');
                    tempDiv.style.color = colorString;
                    document.body.appendChild(tempDiv);
                    const computedColor = window.getComputedStyle(tempDiv).color;
                    document.body.removeChild(tempDiv);
                    colorCache.set(colorString, computedColor);
                }
                return colorCache.get(colorString);
            };
            
            // Smart asset preloading
            const preloadCommonAssets = () => {
                // Preload common patterns and gradients
                const commonPatterns = [
                    'linear-gradient(45deg, #667eea, #764ba2)',
                    'radial-gradient(circle, #ffd700, #ffb347)',
                    'linear-gradient(135deg, #10b981, #059669)',
                    'radial-gradient(circle, #ff6b6b, #4ecdc4, #45b7d1)'
                ];
                
                commonPatterns.forEach(pattern => {
                    const tempDiv = document.createElement('div');
                    tempDiv.style.background = pattern;
                    document.body.appendChild(tempDiv);
                    document.body.removeChild(tempDiv);
                });
            };
            
            // Initialize preloaded assets
            preloadCommonAssets();
            
            // Security: Generate secure session ID
            function generateSecureSessionId() {
                const timestamp = Date.now().toString(36);
                const randomPart = Math.random().toString(36).substring(2, 15);
                return `session_${timestamp}_${randomPart}`;
            }
            
            // Security: Rate limiting
            const checkRateLimit = () => {
                const now = Date.now();
                const timeWindow = 60000; // 1 minute
                const maxRequests = 30; // Max 30 requests per minute
                
                // Reset counter if time window passed
                if (now - lastRequestTime > timeWindow) {
                    setRequestCount(0);
                    setLastRequestTime(now);
                    setIsRateLimited(false);
                    return true;
                }
                
                // Check if rate limited
                if (requestCount >= maxRequests) {
                    setIsRateLimited(true);
                    setTimeout(() => {
                        setIsRateLimited(false);
                        setRequestCount(0);
                    }, timeWindow);
                    return false;
                }
                
                setRequestCount(prev => prev + 1);
                return true;
            };
            
            // Security: Input validation and sanitization
            const sanitizeInput = (input) => {
                if (typeof input !== 'string') return '';
                
                return input
                    .replace(/<script[^>]*>.*?<\/script>/gi, '') // Remove script tags
                    .replace(/javascript:/gi, '') // Remove javascript URLs
                    .replace(/vbscript:/gi, '') // Remove vbscript URLs
                    .replace(/on\w+\s*=/gi, '') // Remove event handlers
                    .replace(/<iframe[^>]*>/gi, '') // Remove iframes
                    .replace(/<object[^>]*>/gi, '') // Remove objects
                    .replace(/<embed[^>]*>/gi, '') // Remove embeds
                    .trim()
                    .substring(0, 1000); // Limit input length
            };
            
            // Security: Production-ready security headers
            const applyProductionSecurity = () => {
                // Set real security headers (would be implemented server-side in production)
                const securityConfig = {
                    // Content Security Policy - stricter for production
                    csp: "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: blob: https:; media-src 'self' blob:; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://api.openai.com https://api.anthropic.com; frame-src 'none'; object-src 'none';",
                    
                    // Security Headers
                    headers: {
                        'X-Content-Type-Options': 'nosniff',
                        'X-Frame-Options': 'DENY',
                        'X-XSS-Protection': '1; mode=block',
                        'Referrer-Policy': 'strict-origin-when-cross-origin',
                        'Permissions-Policy': 'camera=(), microphone=(), geolocation=(), payment=()',
                        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
                        'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; media-src 'self' blob:; frame-src 'none'; object-src 'none';"
                    },
                    
                    // Rate limiting configuration
                    rateLimit: {
                        windowMs: 15 * 60 * 1000, // 15 minutes
                        max: 100, // limit each IP to 100 requests per windowMs
                        message: 'Too many requests from this IP, please try again after 15 minutes',
                        standardHeaders: true,
                        legacyHeaders: false,
                    },
                    
                    // File upload security
                    uploadSecurity: {
                        maxFileSize: 10 * 1024 * 1024, // 10MB
                        maxFiles: 5,
                        allowedTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/ogg'],
                        scanForMalware: true,
                        virusScan: true // Would integrate with virus scanning service
                    },
                    
                    // Data protection
                    dataProtection: {
                        encryptAtRest: true,
                        encryptInTransit: true,
                        dataRetention: 30, // days
                        anonymization: true,
                        gdprCompliant: true,
                        auditLogging: true
                    }
                };
                
                console.log('üîí Production Security Configuration:', securityConfig);
                
                // Store security config for monitoring
                window.helmSecurityConfig = securityConfig;
                
                // Log security status
                console.log('üõ°Ô∏è Security Status:', {
                    csp: 'Applied',
                    headers: 'Applied',
                    rateLimit: 'Active',
                    fileSecurity: 'Active',
                    dataProtection: 'Active',
                    timestamp: new Date().toISOString()
                });
            };
            
            // Security: Initialize production security measures
            applyProductionSecurity();
            
            // Security: AI-Powered Security Assistant
            const aiSecurityAssistant = {
                // AI analyzes security patterns and provides recommendations
                analyzeSecurityPatterns: (input, context) => {
                    const securityAnalysis = {
                        threatLevel: 'low',
                        patterns: [],
                        recommendations: [],
                        riskScore: 0,
                        aiConfidence: 0.85
                    };
                    
                    // AI analyzes input for security threats
                    const securityPatterns = [
                        { pattern: /<script[^>]*>.*?<\/script>/gi, threat: 'high', description: 'Script injection attempt' },
                        { pattern: /javascript:/gi, threat: 'medium', description: 'JavaScript URL injection' },
                        { pattern: /vbscript:/gi, threat: 'medium', description: 'VBScript injection' },
                        { pattern: /<iframe[^>]*>/gi, threat: 'medium', description: 'Iframe injection attempt' },
                        { pattern: /<object[^>]*>/gi, threat: 'medium', description: 'Object injection attempt' },
                        { pattern: /<embed[^>]*>/gi, threat: 'medium', description: 'Embed injection attempt' },
                        { pattern: /on\w+\s*=/gi, threat: 'medium', description: 'Event handler injection' },
                        { pattern: /eval\s*\(/gi, threat: 'high', description: 'Code execution attempt' },
                        { pattern: /Function\s*\(/gi, threat: 'high', description: 'Function constructor abuse' },
                        { pattern: /setTimeout\s*\(/gi, threat: 'medium', description: 'Timer manipulation' },
                        { pattern: /setInterval\s*\(/gi, threat: 'medium', description: 'Interval manipulation' },
                        { pattern: /data:text\/html/gi, threat: 'high', description: 'Data URI HTML injection' },
                        { pattern: /document\.cookie/gi, threat: 'low', description: 'Cookie manipulation' },
                        { pattern: /localStorage\.setItem/gi, threat: 'low', description: 'Local storage manipulation' },
                        { pattern: /sessionStorage\.setItem/gi, threat: 'low', description: 'Session storage manipulation' }
                    ];
                    
                    // AI analyzes each pattern
                    securityPatterns.forEach(securityPattern => {
                        if (securityPattern.pattern.test(input)) {
                            securityAnalysis.patterns.push(securityPattern.description);
                            securityAnalysis.threatLevel = securityAnalysis.threatLevel === 'high' ? 'high' : securityAnalysis.threatLevel;
                            securityAnalysis.riskScore += securityPattern.threat === 'high' ? 30 : securityPattern.threat === 'medium' ? 15 : 5;
                        }
                    });
                    
                    // AI provides context-aware recommendations
                    securityAnalysis.recommendations = generateSecurityRecommendations(securityAnalysis, context);
                    
                    return securityAnalysis;
                },
                
                // AI generates security recommendations based on analysis
                generateSecurityRecommendations: (analysis, context) => {
                    const recommendations = [];
                    
                    if (analysis.threatLevel === 'high') {
                        recommendations.push('üö® HIGH RISK: Immediate action required');
                        recommendations.push('üîí Block this request immediately');
                        recommendations.push('üìä Log security event for review');
                        recommendations.push('üë§ Consider temporary IP ban');
                    } else if (analysis.threatLevel === 'medium') {
                        recommendations.push('‚ö†Ô∏è MEDIUM RISK: Review required');
                        recommendations.push('üîí Sanitize input before processing');
                        recommendations.push('üìä Log for monitoring');
                        recommendations.push('üë§ Consider rate limiting');
                    } else if (analysis.riskScore > 10) {
                        recommendations.push('üîç LOW RISK: Monitor closely');
                        recommendations.push('üîí Apply standard sanitization');
                    }
                    
                    // Context-aware recommendations
                    if (context.action === 'fileUpload') {
                        recommendations.push('üìÅ Scan file for malware');
                        recommendations.push('üîí Validate file type and size');
                    } else if (context.action === 'userInput') {
                        recommendations.push('üí¨ Sanitize user input');
                        recommendations.push('üîí Check for encoding issues');
                    }
                    
                    return recommendations;
                },
                
                // AI monitors for emerging threats
                monitorEmergingThreats: (activityLog) => {
                    const threatIndicators = [
                        'repeated_failed_attempts',
                        'unusual_request_patterns',
                        'suspicious_user_agents',
                        'anomalous_file_uploads',
                        'rapid_successive_requests',
                        'unusual_error_patterns'
                    ];
                    
                    const threatAnalysis = {
                        hasThreats: false,
                        threatType: 'none',
                        confidence: 0,
                        recommendations: []
                    };
                    
                    // AI analyzes activity patterns for threats
                    threatIndicators.forEach(indicator => {
                        if (activityLog.includes(indicator)) {
                            threatAnalysis.hasThreats = true;
                            threatAnalysis.threatType = indicator;
                            threatAnalysis.confidence = 0.75;
                            threatAnalysis.recommendations.push(`üö® Emerging threat detected: ${indicator}`);
                        }
                    });
                    
                    return threatAnalysis;
                },
                
                // AI generates security reports
                generateSecurityReport: (timeframe) => {
                    const report = {
                        timestamp: new Date().toISOString(),
                        timeframe: timeframe,
                        securityStatus: 'Secure',
                        threatsBlocked: 0,
                        threatsDetected: 0,
                        riskLevel: 'Low',
                        aiRecommendations: [],
                        automatedActions: []
                    };
                    
                    // AI analyzes recent security events
                    console.log('ü§ñ AI Security Report Generation:', {
                        timeframe,
                        status: 'Analyzing security events...',
                        timestamp: new Date().toISOString()
                    });
                    
                    return report;
                },
                
                // Security: AI provides security training recommendations
                const getSecurityTraining = () => {
                    const trainingModules = [
                        {
                            title: 'Input Validation Best Practices',
                            content: 'Always sanitize user input, validate file types, check for malicious patterns',
                            level: 'Essential',
                            duration: '15 minutes'
                        },
                        {
                            title: 'File Upload Security',
                            content: 'Validate file types, scan for malware, implement size limits, use secure storage',
                            level: 'Essential',
                            duration: '20 minutes'
                        },
                        {
                            title: 'Threat Detection',
                            content: 'Monitor for suspicious patterns, analyze user behavior, implement automated blocking',
                            level: 'Advanced',
                            duration: '30 minutes'
                        },
                        {
                            title: 'Security Monitoring',
                            content: 'Set up comprehensive logging, implement real-time alerts, create security dashboards',
                            level: 'Advanced',
                            duration: '25 minutes'
                        },
                        {
                            title: 'Compliance & Regulations',
                            content: 'GDPR compliance, data protection, privacy policies, audit requirements',
                            level: 'Expert',
                            duration: '45 minutes'
                        }
                    ];
                    
                    return trainingModules;
                };
                const aiAnalysis = aiSecurityAssistant.analyzeSecurityPatterns(
                    JSON.stringify(details),
                    { action, timestamp: new Date().toISOString() }
                );
                
                // If AI detects threats, take action
                if (aiAnalysis.threatLevel === 'high') {
                    console.warn('üö® AI-Detected High-Risk Activity:', {
                        action,
                        details,
                        patterns: aiAnalysis.patterns,
                        riskScore: aiAnalysis.riskScore,
                        recommendations: aiAnalysis.recommendations,
                        sessionId,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Add AI security alert to chat
                    const aiSecurityAlert = {
                        content: `ü§ñ AI Security Alert: ${aiAnalysis.threatLevel.toUpperCase()} risk detected!\n\nüìã Patterns Found: ${aiAnalysis.patterns.join(', ')}\n\nüõ°Ô∏è Recommendations:\n${aiAnalysis.recommendations.join('\n')}\n\nüìä Risk Score: ${aiAnalysis.riskScore}/100\n\nThis request has been blocked for security reasons.`,
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isError: true,
                        isAISecurity: true
                    };
                    
                    setMessages(prev => [...prev, aiSecurityAlert]);
                    return true;
                } else if (aiAnalysis.riskScore > 10) {
                    console.warn('‚ö†Ô∏è AI-Detected Medium-Risk Activity:', {
                        action,
                        details,
                        patterns: aiAnalysis.patterns,
                        riskScore: aiAnalysis.riskScore,
                        recommendations: aiAnalysis.recommendations,
                        sessionId,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Add AI security warning to chat
                    const aiSecurityWarning = {
                        content: `‚ö†Ô∏è AI Security Warning: ${aiAnalysis.threatLevel.toUpperCase()} risk detected.\n\nüìã Patterns Found: ${aiAnalysis.patterns.join(', ')}\n\nüí° Recommendations:\n${aiSecurityRecommendations.join('\n')}\n\nüìä Risk Score: ${aiAnalysis.riskScore}/100\n\nProceed with caution.`,
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isAISecurity: true
                    };
                    
                    setMessages(prev => [...prev, aiSecurityWarning]);
                }
                
                // Log AI security analysis for monitoring
                console.log('ü§ñ AI Security Analysis:', {
                    action,
                    details,
                    analysis: aiAnalysis,
                    timestamp: new Date().toISOString()
                });
                
                return false; // Allow action to proceed for low/medium risk
            };
            
            // Security: Validate user session
            const validateSession = () => {
                const sessionAge = Date.now() - parseInt(sessionId.split('_')[1], 36);
                const maxSessionAge = 24 * 60 * 60 * 1000; // 24 hours
                
                if (sessionAge > maxSessionAge) {
                    const newSessionId = generateSecureSessionId();
                    setSessionId(newSessionId);
                    
                    const sessionAlert = {
                        content: 'üîÑ Session refreshed for security purposes.',
                        isUser: false,
                        timestamp: new Date().toISOString()
                    };
                    
                    setMessages(prev => [...prev, sessionAlert]);
                }
            };
            
            // Security: Session validation every hour
            setInterval(validateSession, 60 * 60 * 1000);
            
            // Interactive confirmation system
            const generateConfirmationQuestions = (request, detection) => {
                const questions = [];
                const lowerRequest = request.toLowerCase();
                
                // Style-specific questions
                if (detection.intent === 'artStyle') {
                    const artStyle = extractArtStyle(request);
                    
                    questions.push({
                        id: 'style_specifics',
                        question: `What specific ${artStyle} style details would you like?`,
                        options: getArtStyleOptions(artStyle),
                        required: false
                    });
                    
                    if (uploadedFiles.filter(f => f.type === 'image').length === 0) {
                        questions.push({
                            id: 'reference_photo',
                            question: 'Would you like to upload a reference photo for better results?',
                            options: ['Yes, upload photo', 'No, use sample', 'Maybe later'],
                            required: false
                        });
                    }
                }
                
                // Logo-specific questions
                if (detection.intent === 'logo') {
                    questions.push({
                        id: 'logo_type',
                        question: 'What type of logo are you looking for?',
                        options: ['Minimalist', 'Detailed', 'Modern', 'Classic', 'Abstract', 'Text-based'],
                        required: true
                    });
                    
                    questions.push({
                        id: 'color_scheme',
                        question: 'What color scheme would you prefer?',
                        options: ['Bright & Bold', 'Dark & Professional', 'Monochrome', 'Colorful', 'Pastel', 'Custom'],
                        required: false
                    });
                    
                    if (!lowerRequest.includes('for') && !lowerRequest.includes('of')) {
                        questions.push({
                            id: 'logo_purpose',
                            question: 'What is this logo for? (company, project, personal, etc.)',
                            options: ['Company/Business', 'Personal Project', 'Team/Group', 'Product/Service', 'Event', 'Other'],
                            required: false
                        });
                    }
                }
                
                // Emote-specific questions
                if (detection.intent === 'emote') {
                    const theme = extractTheme(request);
                    
                    questions.push({
                        id: 'emote_details',
                        question: `What specific ${theme} expression details would you like?`,
                        options: getEmoteThemeOptions(theme),
                        required: false
                    });
                    
                    if (uploadedFiles.filter(f => f.type === 'image').length === 0) {
                        questions.push({
                            id: 'emote_reference',
                            question: 'Would you like to base this emote on a real person?',
                            options: ['Yes, upload photo', 'No, create generic', 'Use previous uploads'],
                            required: false
                        });
                    }
                }
                
                // Badge-specific questions
                if (detection.intent === 'badge') {
                    questions.push({
                        id: 'badge_purpose',
                        question: 'What type of badge do you need?',
                        options: ['Name Badge', 'ID Badge', 'Event Badge', 'Achievement Badge', 'Security Badge'],
                        required: true
                    });
                    
                    questions.push({
                        id: 'badge_info',
                        question: 'What information should be on the badge?',
                        options: ['Name Only', 'Name + Title', 'Name + ID', 'Name + Photo', 'Custom'],
                        required: true
                    });
                }
                
                // General creative questions
                questions.push({
                    id: 'size_preference',
                    question: 'What size would you prefer?',
                    options: ['Small (200x200)', 'Medium (400x400)', 'Large (600x600)', 'Square', 'Rectangular'],
                    required: false
                });
                
                questions.push({
                    id: 'usage',
                    question: 'How will you use this asset?',
                    options: ['Digital Only', 'Print', 'Web/Social Media', 'Game/App', 'Presentation'],
                    required: false
                });
                
                return questions;
            };
            
            const getArtStyleOptions = (artStyle) => {
                const options = {
                    'cartoon': ['Bold outlines', 'Bright colors', 'Exaggerated features', 'Simple shapes', 'Comic style'],
                    'chibi': ['Super cute', 'Big eyes', 'Small body', 'Pastel colors', 'Kawaii style'],
                    'anime': ['Large eyes', 'Detailed hair', 'Sharp lines', 'Manga style', 'Expressive'],
                    'sketch': ['Hand-drawn', 'Rough lines', 'Pencil style', 'Artistic', 'Loose'],
                    'pixel art': ['8-bit style', 'Retro gaming', 'Limited colors', 'Blocky', 'NES style'],
                    'watercolor': ['Soft edges', 'Blended colors', 'Artistic', 'Painting style', 'Abstract']
                };
                return options[artStyle] || ['Standard style'];
            };
            
            const getEmoteThemeOptions = (theme) => {
                const options = {
                    'happy': ['Big smile', 'Laughing', 'Joyful', 'Excited', 'Cheerful'],
                    'cool': ['Sunglasses', 'Confident', 'Relaxed', 'Stylish', 'Chill'],
                    'love': ['Heart eyes', 'Blushing', 'Romantic', 'Adoring', 'Sweet'],
                    'thinking': ['Thought bubble', 'Pondering', 'Curious', 'Wondering', 'Hmmm'],
                    'sad': ['Crying', 'Tears', 'Upset', 'Melancholy', 'Blue'],
                    'angry': ['Furious', 'Mad', 'Upset', 'Intense', 'Frustrated'],
                    'surprised': ['Shocked', 'Wide eyes', 'Amazed', 'Astonished', 'Wow'],
                    'sleepy': ['Yawning', 'Tired', 'Drowsy', 'Exhausted', 'Zzz'],
                    'crazy': ['Wild', 'Energetic', 'Wacky', 'Insane', 'Bonkers'],
                    'smart': ['Glasses', 'Brainy', 'Intelligent', 'Nerdy', 'Clever']
                };
                return options[theme] || ['Standard expression'];
            };
            
            const startConfirmationProcess = (request, detection) => {
                const questions = generateConfirmationQuestions(request, detection);
                
                if (questions.length > 0) {
                    setConfirmationMode(true);
                    setPendingRequest(request);
                    setConfirmationQuestions(questions);
                    setConfirmationAnswers({});
                    
                    // Add confirmation message
                    const confirmationMessage = {
                        content: `ü§î I have a few questions to help me create exactly what you want:\n\n${questions.map((q, index) => 
                            `${index + 1}. ${q.question}\n   Options: ${q.options.join(', ')}${q.required ? ' (Required)' : ''}`
                        ).join('\n\n')}\n\nPlease answer each question by typing the number or your choice.`,
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isConfirmation: true
                    };
                    
                    setMessages(prev => [...prev, confirmationMessage]);
                    return true;
                }
                
                return false;
            };
            
            const handleConfirmationAnswer = (answer) => {
                const trimmedAnswer = answer.trim().toLowerCase();
                
                // Find which question this answers
                const currentQuestion = confirmationQuestions.find(q => !confirmationAnswers[q.id]);
                
                if (!currentQuestion) {
                    // All questions answered, proceed with creation
                    finalizeAssetCreation();
                    return;
                }
                
                // Check if answer is a number (option selection)
                const questionIndex = confirmationQuestions.indexOf(currentQuestion);
                if (/^\d+$/.test(trimmedAnswer)) {
                    const optionIndex = parseInt(trimmedAnswer) - 1;
                    if (optionIndex >= 0 && optionIndex < currentQuestion.options.length) {
                        setConfirmationAnswers(prev => ({
                            ...prev,
                            [currentQuestion.id]: currentQuestion.options[optionIndex]
                        }));
                    }
                } else {
                    // Text answer
                    setConfirmationAnswers(prev => ({
                        ...prev,
                        [currentQuestion.id]: answer
                    }));
                }
                
                // Check if all required questions are answered
                const allRequiredAnswered = confirmationQuestions
                    .filter(q => q.required)
                    .every(q => confirmationAnswers[q.id]);
                
                if (allRequiredAnswered) {
                    // Check if there are more unanswered questions
                    const nextQuestion = confirmationQuestions.find(q => !confirmationAnswers[q.id]);
                    if (!nextQuestion) {
                        // All questions answered
                        finalizeAssetCreation();
                    } else {
                        // Ask next question
                        const nextQuestionMessage = {
                            content: `‚úÖ Got it! Next question:\n\n${nextQuestion.question}\n   Options: ${nextQuestion.options.join(', ')}${nextQuestion.required ? ' (Required)' : ''}`,
                            isUser: false,
                            timestamp: new Date().toISOString(),
                            isConfirmation: true
                        };
                        setMessages(prev => [...prev, nextQuestionMessage]);
                    }
                } else {
                    // Ask for missing required answers
                    const missingRequired = confirmationQuestions.filter(q => q.required && !confirmationAnswers[q.id]);
                    const missingMessage = {
                        content: `‚ùì I still need answers to these required questions:\n\n${missingRequired.map(q => `‚Ä¢ ${q.question}`).join('\n')}`,
                        isUser: false,
                        timestamp: new Date().toISOString(),
                        isConfirmation: true
                    };
                    setMessages(prev => [...prev, missingMessage]);
                }
            };
            
            const finalizeAssetCreation = () => {
                setConfirmationMode(false);
                
                // Create enhanced request with confirmation details
                const enhancedRequest = enhanceRequestWithAnswers(pendingRequest, confirmationAnswers);
                
                // Add confirmation summary
                const summaryMessage = {
                    content: `üéØ Perfect! Based on your answers, I'll create:\n\n${formatConfirmationSummary(confirmationAnswers)}\n\nCreating your ${getAssetType(enhancedRequest)} now...`,
                    isUser: false,
                    timestamp: new Date().toISOString(),
                    isConfirmation: true
                };
                
                setMessages(prev => [...prev, summaryMessage]);
                
                // Proceed with asset creation using enhanced request
                setTimeout(() => {
                    const detection = detectIntent(enhancedRequest.toLowerCase());
                    if (detection.isAssetRequest) {
                        if (detection.intent === 'logo' || detection.intent === 'emote' || detection.intent === 'poker' || 
                            detection.intent === 'badge' || detection.intent === 'border' || detection.intent === 'banner' || detection.intent === 'shield' ||
                            detection.intent === 'artStyle') {
                            createLogo(enhancedRequest);
                        } else if (detection.intent === 'audio') {
                            createAudio(enhancedRequest);
                        }
                    }
                }, 1000);
                
                // Reset confirmation state
                setPendingRequest(null);
                setConfirmationQuestions([]);
                setConfirmationAnswers({});
            };
            
            const enhanceRequestWithAnswers = (request, answers) => {
                let enhancedRequest = request;
                
                // Add confirmation details to request
                Object.entries(answers).forEach(([key, value]) => {
                    if (value && value !== 'No, use sample' && value !== 'Maybe later') {
                        enhancedRequest += ` (${key}: ${value})`;
                    }
                });
                
                return enhancedRequest;
            };
            
            const formatConfirmationSummary = (answers) => {
                return Object.entries(answers)
                    .filter(([key, value]) => value && value !== 'No, use sample' && value !== 'Maybe later')
                    .map(([key, value]) => `‚Ä¢ ${key.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}: ${value}`)
                    .join('\n');
            };
            
            return (
                <div className="dashboard-container">
                    <div className="header">
                        <h1>üõ°Ô∏è Helm Enhanced Chat</h1>
                        <p>Natural AI conversation with smart model selection</p>
                    </div>
                    
                    <div className="status-bar">
                        <div className="status-item">
                            <div>ü§ñ Helm Status</div>
                            <div>{helmStatus.running ? 'üü¢ Online' : 'üî¥ Offline'}</div>
                        </div>
                        <div className="status-item">
                            <div>üß† Learning</div>
                            <div>{helmStatus.running ? 'üü¢ Active' : 'üî¥ Inactive'}</div>
                        </div>
                        <div className="status-item">
                            <div>üí¨ Messages</div>
                            <div>{messages.length}</div>
                        </div>
                    </div>
                    
                    <div className="chat-section">
                        <h2>üí¨ Chat with Helm</h2>
                        
                        <div className="chat-container">
                            {messages.map((message, index) => (
                                <div key={index} className={`message-bubble ${message.isUser ? 'user' : 'assistant'}`}>
                                    {!message.isUser && (
                                        <div className="message-avatar">üõ°Ô∏è</div>
                                    )}
                                    <div className="message-content">
                                        {message.isApproval ? (
                                            <div>
                                                {message.imageUrl && (
                                                    <img 
                                                        src={message.imageUrl} 
                                                        alt="Generated Asset" 
                                                        style={{
                                                            maxWidth: '100%',
                                                            borderRadius: '8px',
                                                            border: '2px solid #3a3a5e',
                                                            marginBottom: '8px'
                                                        }}
                                                    />
                                                )}
                                                {message.audioUrl && (
                                                    <audio 
                                                        controls 
                                                        style={{
                                                            width: '100%',
                                                            borderRadius: '8px',
                                                            marginBottom: '8px'
                                                        }}
                                                    >
                                                        <source src={message.audioUrl} type="audio/wav" />
                                                        Your browser does not support the audio element.
                                                    </audio>
                                                )}
                                                <div style={{ marginBottom: '10px' }}>{message.content}</div>
                                                <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                                                    <button
                                                        onClick={() => approveAsset(message.assetId)}
                                                        style={{
                                                            padding: '6px 12px',
                                                            background: 'linear-gradient(135deg, #10b981, #059669)',
                                                            color: 'white',
                                                            border: 'none',
                                                            borderRadius: '6px',
                                                            cursor: 'pointer',
                                                            fontSize: '12px',
                                                            fontWeight: '500'
                                                        }}
                                                    >
                                                        ‚úÖ Approve & Implement
                                                    </button>
                                                    <button
                                                        onClick={() => rejectAsset(message.assetId)}
                                                        style={{
                                                            padding: '6px 12px',
                                                            background: 'linear-gradient(135deg, #ef4444, #dc2626)',
                                                            color: 'white',
                                                            border: 'none',
                                                            borderRadius: '6px',
                                                            cursor: 'pointer',
                                                            fontSize: '12px',
                                                            fontWeight: '500'
                                                        }}
                                                    >
                                                        ‚ùå Reject
                                                    </button>
                                                    {message.isDownloadable && (
                                                        <button
                                                            onClick={() => downloadAsset(message)}
                                                            style={{
                                                                padding: '6px 12px',
                                                                background: 'linear-gradient(135deg, #3b82f6, #2563eb)',
                                                                color: 'white',
                                                                border: 'none',
                                                                borderRadius: '6px',
                                                                cursor: 'pointer',
                                                                fontSize: '12px',
                                                                fontWeight: '500'
                                                            }}
                                                        >
                                                            üì• Download
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        ) : message.isImplementation ? (
                                            <div style={{
                                                background: 'rgba(16, 185, 129, 0.1)',
                                                border: '1px solid #10b981',
                                                borderRadius: '8px',
                                                padding: '12px',
                                                whiteSpace: 'pre-line'
                                            }}>
                                                {message.content}
                                            </div>
                                        ) : message.isUpload ? (
                                            <div style={{
                                                background: 'rgba(59, 130, 246, 0.1)',
                                                border: '1px solid #3b82f6',
                                                borderRadius: '8px',
                                                padding: '12px',
                                                whiteSpace: 'pre-line'
                                            }}>
                                                {message.content}
                                            </div>
                                        ) : message.isDownload ? (
                                            <div style={{
                                                background: 'rgba(16, 185, 129, 0.1)',
                                                border: '1px solid #10b981',
                                                borderRadius: '8px',
                                                padding: '12px',
                                                whiteSpace: 'pre-line'
                                            }}>
                                                {message.content}
                                            </div>
                                        ) : message.isError ? (
                                            <div style={{
                                                background: 'rgba(239, 68, 68, 0.1)',
                                                border: '1px solid #ef4444',
                                                borderRadius: '8px',
                                                padding: '12px',
                                                whiteSpace: 'pre-line'
                                            }}>
                                                {message.content}
                                            </div>
                                        ) : message.isConfirmation ? (
                                            <div style={{
                                                background: 'rgba(59, 130, 246, 0.1)',
                                                border: '1px solid #3b82f6',
                                                borderRadius: '8px',
                                                padding: '12px',
                                                whiteSpace: 'pre-line'
                                            }}>
                                                {message.content}
                                            </div>
                                        ) : (
                                            <div>{message.content}</div>
                                        )}
                                        <div className="message-time">
                                            {new Date(message.timestamp).toLocaleTimeString()}
                                        </div>
                                    </div>
                                    {message.isUser && (
                                        <div className="message-avatar">üë§</div>
                                    )}
                                </div>
                            ))}
                            
                            {isLoading && (
                                <div className="message-bubble assistant">
                                    <div className="message-avatar">üõ°Ô∏è</div>
                                    <div className="message-content">
                                        <div className="typing-indicator">
                                            <div className="typing-dot"></div>
                                            <div className="typing-dot"></div>
                                            <div className="typing-dot"></div>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        <div className="chat-input-container">
                            <button 
                                className="upload-button" 
                                onClick={() => setShowUploadModal(true)}
                                title="Upload files for reference"
                            >
                                üìÅ Upload
                            </button>
                            <input
                                type="text"
                                className="chat-input"
                                placeholder="Type your message..."
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                onKeyPress={handleKeyPress}
                                disabled={isLoading}
                            />
                            <select 
                                className="model-select"
                                value={selectedModel} 
                                onChange={(e) => setSelectedModel(e.target.value)}
                            >
                                {availableModels.map(model => (
                                    <option key={model} value={model}>{model}</option>
                                ))}
                            </select>
                            <button 
                                className="send-button" 
                                onClick={sendMessage}
                                disabled={isLoading || !input.trim()}
                            >
                                {isLoading ? '‚è≥ Thinking...' : 'üöÄ Send'}
                            </button>
                        </div>
                    </div>
                    
                    <div className="logo-display">
                        <canvas id="logo-canvas" width="200" height="200" style={{ display: 'none' }}></canvas>
                    </div>
                    
                    {/* Upload Modal */}
                    {showUploadModal && (
                        <div className="upload-modal">
                            <div className="upload-modal-content">
                                <div className="upload-modal-header">
                                    <h3 className="upload-modal-title">üìÅ Upload Files for Reference</h3>
                                    <button 
                                        className="close-modal-btn"
                                        onClick={() => setShowUploadModal(false)}
                                    >
                                        √ó
                                    </button>
                                </div>
                                
                                <div 
                                    className={`file-upload-area ${isDragging ? 'dragging' : ''}`}
                                    onDragOver={handleDragOver}
                                    onDragLeave={handleDragLeave}
                                    onDrop={handleDrop}
                                    onClick={() => document.getElementById('modal-file-input').click()}
                                >
                                    <div className="file-upload-icon">üìÅ</div>
                                    <div className="file-upload-text">
                                        {isDragging ? 'Drop files here...' : 'Click to upload or drag & drop'}
                                    </div>
                                    <div className="file-upload-hint">
                                        Images (JPG, PNG, GIF, WebP) ‚Ä¢ Audio (WAV, MP3, OGG)
                                    </div>
                                    <input
                                        id="modal-file-input"
                                        type="file"
                                        className="file-input"
                                        multiple
                                        accept="image/*,audio/*"
                                        onChange={(e) => {
                                            handleFileUpload(e.target.files);
                                            setShowUploadModal(false);
                                        }}
                                    />
                                </div>
                                
                                {uploadedFiles.length > 0 && (
                                    <div className="uploaded-files">
                                        <div style={{ color: '#e0e0e0', marginBottom: '10px', fontSize: '14px' }}>
                                            üìã Uploaded Files ({uploadedFiles.length}):
                                        </div>
                                        {uploadedFiles.map(file => (
                                            <div key={file.id} className="uploaded-file">
                                                <div className="uploaded-file-info">
                                                    <div className="uploaded-file-icon">
                                                        {file.type === 'image' ? 'üñºÔ∏è' : 'üéµ'}
                                                    </div>
                                                    {file.type === 'image' && (
                                                        <img 
                                                            src={file.url} 
                                                            alt={file.name}
                                                            className="uploaded-file-preview"
                                                        />
                                                    )}
                                                    <div className="uploaded-file-details">
                                                        <div className="uploaded-file-name">{file.name}</div>
                                                        <div className="uploaded-file-size">{formatFileSize(file.size)}</div>
                                                    </div>
                                                </div>
                                                <button
                                                    className="remove-file-btn"
                                                    onClick={() => removeUploadedFile(file.id)}
                                                >
                                                    Remove
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Render the app using React 18 createRoot API
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<EnhancedHelmChat />);
    </script>
</body>
</html>
