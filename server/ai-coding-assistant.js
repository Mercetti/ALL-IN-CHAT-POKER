/**
 * AI Coding Assistant with Quality Guardrails
 * Integrates with existing AI systems to ensure clean, maintainable code generation
 */

const AICodeQualityGuardian = require('./ai-code-quality-guardian');
const logger = require('./logger');

class AICodingAssistant {
  constructor() {
    this.qualityGuardian = new AICodeQualityGuardian();
    this.context = {};
    this.guidelines = this.qualityGuardian.getCodingGuidelines();
  }

  /**
   * Initializes the AI coding assistant with current codebase context
   */
  async initialize() {
    try {
      logger.info('Initializing AI Coding Assistant with quality guardrails...');
      
      // Analyze current codebase
      this.context = await this.qualityGuardian.analyzeCodebase('server.js');
      
      logger.info('AI Coding Assistant initialized', {
        functions: this.context.functionCount,
        routes: this.context.routeCount,
        imports: this.context.importCount,
        structure: this.context.codeStructure
      });

      return true;
    } catch (error) {
      logger.error('Failed to initialize AI Coding Assistant', { error: error.message });
      return false;
    }
  }

  /**
   * Generates code with quality validation
   */
  async generateCode(request, options = {}) {
    const {
      type = 'function',
      description,
      context = {},
      validate = true
    } = request;

    try {
      logger.info('AI generating code', { type, description });

      // Generate code using AI (this would integrate with your existing AI system)
      let generatedCode = await this.callAIGeneration(request);

      if (validate) {
        // Validate generated code
        const validation = this.qualityGuardian.validateGeneratedCode(generatedCode, {
          type,
          context: { ...this.context, ...context }
        });

        if (!validation.isValid) {
          logger.warn('Generated code failed validation', { issues: validation.issues });
          
          // Try to fix issues automatically
          generatedCode = await this.autoFixCode(generatedCode, validation.issues);
          
          // Re-validate
          const revalidation = this.qualityGuardian.validateGeneratedCode(generatedCode, context);
          if (!revalidation.isValid) {
            throw new Error(`Code validation failed: ${revalidation.issues.map(i => i.message).join(', ')}`);
          }
        }

        logger.info('Generated code passed validation');
      }

      // Update registries
      this.qualityGuardian.updateRegistries(generatedCode);

      return {
        success: true,
        code: generatedCode,
        suggestions: validation.suggestions || [],
        warnings: validation.issues?.filter(i => i.type !== 'error') || []
      };

    } catch (error) {
      logger.error('AI code generation failed', { error: error.message });
      return {
        success: false,
        error: error.message,
        suggestions: this.getErrorRecoverySuggestions(error)
      };
    }
  }

  /**
   * Calls the AI generation system (integrate with your existing AI)
   */
  async callAIGeneration(request) {
    // This would integrate with your existing AI coding system
    // For now, return a placeholder that follows quality guidelines
    
    const { type, description } = request;
    
    switch (type) {
      case 'function':
        return this.generateFunction(description);
      case 'route':
        return this.generateRoute(description);
      case 'module':
        return this.generateModule(description);
      case 'refactor':
        return this.generateRefactoredCode(description);
      default:
        throw new Error(`Unsupported code generation type: ${type}`);
    }
  }

  /**
   * Generates a function following quality guidelines
   */
  generateFunction(description) {
    return `
/**
 * ${description}
 * Generated by AI with quality guardrails
 */
function generatedFunction(params) {
  // TODO: Implement function logic
  logger.debug('generatedFunction called', { params });
  
  try {
    // Implementation here
    return { success: true };
  } catch (error) {
    logger.error('generatedFunction failed', { error: error.message });
    throw error;
  }
}
    `.trim();
  }

  /**
   * Generates a route following quality guidelines
   */
  generateRoute(description) {
    return `
/**
 * ${description}
 * Generated by AI with quality guardrails
 */
app.get('/generated-endpoint', auth.requireUser, (req, res) => {
  try {
    const result = // TODO: Implement route logic
    
    res.json({ success: true, data: result });
  } catch (error) {
    logger.error('Generated endpoint failed', { error: error.message });
    res.status(500).json({ error: 'internal_error' });
  }
});
    `.trim();
  }

  /**
   * Generates a module following quality guidelines
   */
  generateModule(description) {
    return `
/**
 * ${description}
 * Generated by AI with quality guardrails
 */

const logger = require('../logger');
const { db } = require('../database');

/**
 * Main module functionality
 */
function moduleFunction(params) {
  logger.debug('moduleFunction called', { params });
  
  try {
    // Implementation here
    return { success: true };
  } catch (error) {
    logger.error('moduleFunction failed', { error: error.message });
    throw error;
  }
}

module.exports = {
  moduleFunction
};
    `.trim();
  }

  /**
   * Attempts to automatically fix code issues
   */
  async autoFixCode(code, issues) {
    let fixedCode = code;

    issues.forEach(issue => {
      switch (issue.type) {
        case 'duplicate-function':
          fixedCode = this.fixDuplicateFunction(fixedCode, issue);
          break;
        case 'duplicate-route':
          fixedCode = this.fixDuplicateRoute(fixedCode, issue);
          break;
        case 'server-listen':
          fixedCode = this.removeServerListen(fixedCode);
          break;
        case 'orphaned-code':
          fixedCode = this.fixOrphanedCode(fixedCode, issue);
          break;
      }
    });

    return fixedCode;
  }

  /**
   * Fixes duplicate function issues
   */
  fixDuplicateFunction(code, issue) {
    // Remove duplicate function or rename it
    const funcName = issue.message.match(/Function '([^']+)'/)?.[1];
    if (funcName) {
      // Rename the duplicate function
      return code.replace(
        new RegExp(`function\\s+${funcName}`, 'g'),
        `function ${funcName}Generated`
      );
    }
    return code;
  }

  /**
   * Fixes duplicate route issues
   */
  fixDuplicateRoute(code, issue) {
    // Comment out duplicate route
    return code.replace(
      /(app\.(get|post|put|delete|patch)\s*\(\s*['"`][^'"`]+['"`])/g,
      '// DUPLICATE: $1'
    );
  }

  /**
   * Removes server.listen calls
   */
  removeServerListen(code) {
    return code.replace(/server\.listen\([^)]+\);\s*/g, '');
  }

  /**
   * Fixes orphaned code by adding proper exports
   */
  fixOrphanedCode(code, issue) {
    if (!code.includes('module.exports') && !code.includes('exports')) {
      // Add module.exports at the end
      const functions = this.qualityGuardian.extractFunctions(code);
      if (functions.length > 0) {
        const exportList = functions.join(',\n  ');
        return code + `\n\nmodule.exports = {\n  ${exportList}\n};`;
      }
    }
    return code;
  }

  /**
   * Gets error recovery suggestions
   */
  getErrorRecoverySuggestions(error) {
    return [
      'Review code quality guidelines',
      'Check for duplicate functions or routes',
      'Ensure proper module structure',
      'Validate imports and dependencies',
      'Consider breaking down complex code'
    ];
  }

  /**
   * Provides refactoring assistance
   */
  async suggestRefactoring(targetCode) {
    const analysis = this.qualityGuardian.analyzeStructure(targetCode);
    const suggestions = this.qualityGuardian.generateCleanupSuggestions();

    return {
      analysis,
      suggestions,
      actionPlan: this.createRefactoringPlan(analysis, suggestions)
    };
  }

  /**
   * Creates a refactoring plan
   */
  createRefactoringPlan(analysis, suggestions) {
    const plan = [];

    if (analysis.totalLines > 300) {
      plan.push({
        priority: 'high',
        action: 'split-large-file',
        description: 'Split large file into smaller modules',
        estimatedTime: '30-60 minutes'
      });
    }

    if (analysis.hasMultipleServerListen) {
      plan.push({
        priority: 'critical',
        action: 'fix-server-listen',
        description: 'Remove duplicate server.listen() calls',
        estimatedTime: '5-10 minutes'
      });
    }

    if (analysis.hasConsoleStatements) {
      plan.push({
        priority: 'medium',
        action: 'replace-logging',
        description: 'Replace console statements with logger',
        estimatedTime: '15-30 minutes'
      });
    }

    return plan;
  }

  /**
   * Runs periodic code quality checks
   */
  async runQualityCheck() {
    logger.info('Running periodic code quality check...');

    const issues = [];
    
    // Check for common quality issues
    if (this.context.codeStructure.hasMultipleServerListen) {
      issues.push({
        type: 'critical',
        message: 'Multiple server.listen() calls detected'
      });
    }

    if (this.context.codeStructure.totalLines > 300) {
      issues.push({
        type: 'warning',
        message: 'server.js is large - consider refactoring'
      });
    }

    return {
      healthy: issues.filter(i => i.type === 'critical').length === 0,
      issues,
      recommendations: this.qualityGuardian.generateCleanupSuggestions()
    };
  }
}

module.exports = AICodingAssistant;
